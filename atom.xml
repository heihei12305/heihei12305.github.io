<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://heihei12305.github.io</id>
    <title>heihei12305</title>
    <updated>2019-12-26T03:04:56.740Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://heihei12305.github.io"/>
    <link rel="self" href="https://heihei12305.github.io/atom.xml"/>
    <subtitle>所见即所得，所见即所碍</subtitle>
    <logo>https://heihei12305.github.io/images/avatar.png</logo>
    <icon>https://heihei12305.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, heihei12305</rights>
    <entry>
        <title type="html"><![CDATA[ant-design-pro-vue修改指南🛠]]></title>
        <id>https://heihei12305.github.io/post/ant-design-pro-vue-xiu-gai-zhi-nan</id>
        <link href="https://heihei12305.github.io/post/ant-design-pro-vue-xiu-gai-zhi-nan">
        </link>
        <updated>2019-12-24T15:32:50.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>前一段时间用ant design pro of vue写了俩系统，趁着自己还记得怎么改的，记录一下。</p>
</blockquote>
<h3 id="登录框系列">登录框系列</h3>
<br/>
<p>系列文件📃在 <code>src/views/user</code>下，因为没有复用很多组件（不像ant design pro😭），</p>
<figure data-type="image" tabindex="1"><img src="https://heihei12305.github.io/post-images/1577202288794.png" alt=""></figure>
<br/>
<p>直接修改这三个组件即可😊。</p>
<br/>
<blockquote>
<p>ps:不过这里把请求封装了，而且设计动态权限路由渲染那一套，建议改改形式就好了，其他的谨慎修改。⛏</p>
</blockquote>
<br/>
<h3 id="动态路由系列">动态路由系列</h3>
<br/>
<p>系列文件📃在 <code>src/config/router.config.js</code>,此处涉及动态路由列表渲染的具体情况，包括url，列表项名称，page名称等。</p>
<br/>
<p>例子：</p>
<pre><code>// forms
{
    path: '/index',
    redirect: '/index/welcome',
    component: RouteView,
    meta: { title: '主页', icon: 'form', permission: [ 'form' ] },
    children: [
        {
        path: '/index/welcome',
        name: 'welcome',
        component: () =&gt; import('@/views/form/BasicForm'),
        meta: { title: '欢迎页', keepAlive: true, permission: [ 'form' ] }
        }
    ]
},
</code></pre>
<p>说明：此处路由由forms修改而来，权限列表依旧为form，page名称为主页或者欢迎页。path指的是路由，compont指对应vue组件。🔧</p>
<br/>
<h3 id="跨域篇">跨域篇</h3>
<p>对应文件📃在<code>vue.config.js</code>,把proxy修改到对应后端端口即可。</p>
<pre><code>//此处代码位于vue.config.js 87行
devServer: {
    // development server port 8000
    port: 8000,
    // If you want to turn on the proxy, please remove the mockjs /src/main.jsL11
    proxy: {
      '/api/*': {
        target:'http://localhost:3000',
        // target:'http://202.206.212.212:9000',
        changeOrigin: true
      }
    }
  },
</code></pre>
<h3 id="ant组件使用篇">ant组件使用篇</h3>
<p>官网地址： <a href="http://vue.ant-design.cn/docs/vue/introduce-cn/">ant design vue</a></p>
<br/>
<p>在ant design pro vue 中使用方式：</p>
<ol>
<li>按需加载在<code>src/core/lazy_lib/components_use.js</code></li>
</ol>
<pre><code>//使用示例
import {
  Carousel
} from 'ant-design-vue'
Vue.use(Carousel)
</code></pre>
<p>文件其余部分不动即可，然后就可以直接使用。</p>
<br/>
<ol start="2">
<li>上文中我们引入了<code>Carousel</code>，使用时，我们需要用 <code>a-carousel</code></li>
</ol>
<pre><code>&lt;a-carousel 
    arrows 
    autoplay
    &gt;
    &lt;div
      slot=&quot;prevArrow&quot;
      class=&quot;custom-slick-arrow&quot;
      style=&quot;left: 10px;zIndex: 1&quot;
    &gt;
      &lt;a-icon type=&quot;left-circle&quot; /&gt;
    &lt;/div&gt;
    &lt;div slot=&quot;nextArrow&quot; class=&quot;custom-slick-arrow&quot; style=&quot;right: 10px&quot;&gt;
      &lt;a-icon type=&quot;right-circle&quot; /&gt;
    &lt;/div&gt;
    &lt;div&gt;&lt;h3&gt;重要通知：xxxx新书到啦&lt;/h3&gt;&lt;/div&gt;
    &lt;div&gt;&lt;h3&gt;老师给个优吧！&lt;/h3&gt;&lt;/div&gt;
    &lt;div&gt;&lt;h3&gt;不看错亿呀！图书馆使用指南&lt;/h3&gt;&lt;/div&gt;
  &lt;/a-carousel&gt;
</code></pre>
<br/>
<h3 id="取消mock篇">取消mock篇</h3>
<p>使用 ant design pro vue时，请求会被mock全部拦截😢</p>
<br/>
<p>取消其实也简单，Mock 在 main.js 中经行引入，你可以查看该文件的源代码，并找到 import './mock' 这样的代码。（去除它 可完整的将项目中的 mock 拦截去除）</p>
<br/>
<h3 id="请求发送篇">请求发送篇</h3>
<br/>
<p>别问，问就是axios😊<br/></p>
<p>本来项目就有用，只是它又给再封装📦了一层。<br/></p>
<p>使用很简单，引入，然后直接使用即可。</p>
<pre><code>&lt;script&gt;
import axios from 'axios'
methods: {
    getData () {
        axios.post('/api/admin/salary', {
        params: {
            'username': this.$store.getters.userInfo.roleId
        }
        }).then(result =&gt; {
        console.log(result.data.data)
        this.dataSource = result.data.data
        for (let i = 0, len = this.dataSource.length; i &lt; len; i++) {
            this.dataSource[i].key = i
        }
        })
    },
&lt;/script&gt;
</code></pre>
<h3 id="vue基础篇">vue基础篇</h3>
<p>可能使用到的vue的一些基础属性📖</p>
<ul>
<li>mountd  生命周期钩子函数的一个</li>
<li>computed 计算属性</li>
<li>data 使用的必须为返回值</li>
<li>components 使用的组件</li>
</ul>
<p>其余具体的 ant 组件相关配置见 ant design 组件库</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[webpack-进阶用法🚔]]></title>
        <id>https://heihei12305.github.io/post/webpack-jin-jie-yong-fa</id>
        <link href="https://heihei12305.github.io/post/webpack-jin-jie-yong-fa">
        </link>
        <updated>2019-12-23T15:30:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="自动清理构建目录产物">🏍 自动清理构建目录产物</h2>
<br/>
<h3 id="通过-npm-scripts清理构建目录">🚲 通过 <code>npm scripts</code>清理构建目录</h3>
<pre><code>rm -rf ./dist &amp;&amp; webpack
rimraf ./dist &amp;&amp; webpack
</code></pre>
<p>不过这个 <code>rm -rf</code> 看起来有点😨，不很优雅。</p>
<br/>
<h3 id="通过-clean-webpack-plugin-插件">🛵 通过 <code>clean-webpack-plugin</code> 插件</h3>
<br/>
<p><b>默认会删除output指定的输出目录</b></p>
<br/>
<pre><code>module.exports = {
    entry:{
        app:'./src/app.js',
        search:'./src/search.js'
    },
    output:{
        filename:'[name][chunkhash:8].js',
        path:__dirname+'/dist'
    },
    plugins:[
        new CleanWebpackPlugin()
    ]
};
</code></pre>
<br/>
<hr>
<br/>
<h2 id="postcss插件自动补全css3前缀">postCss插件自动补全css3前缀🏄‍♀</h2>
<h3 id="为什么css3需要添加前缀呢">为什么css3需要添加前缀呢？🏊‍♀</h3>
<p>原因：因为浏览器的标准还没有完全统一，目前来看主要还有四种浏览器内核，分别是：</p>
<ul>
<li>⛹️‍♀️Trident(-ms)</li>
<li>⛹Geko(-moz)</li>
<li>🤾‍♀Webkit(-webkit)</li>
<li>🤾‍♂Presto(-o)</li>
</ul>
<br/>
<h3 id="使用autoprefixer插件">使用autoprefixer插件🏊</h3>
<br/>
<p>原理：🤼‍♂根据<a href="https://caniuse.com/">Cab I Use规则</a></p>
<br/>
<pre><code>module.exports = {
  module:{
    rules:[
      {
        test:/\.less$/,
        use:[
          'style-loader',
          'css-loader',
          'less-loader',
           {
            loader:'postcss-loader',
            options:{
              plugins:() =&gt; {
                require('autoprefixer')({
                    browsers:[&quot;last 2 version&quot;,&quot;&gt;1%&quot;,&quot;iOS 7&quot;]
                })
              }
            }
          }
        ]
       }
     ]
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[webpack-js,html,css压缩🗜️]]></title>
        <id>https://heihei12305.github.io/post/webpack-jshtmlcss-ya-suo</id>
        <link href="https://heihei12305.github.io/post/webpack-jshtmlcss-ya-suo">
        </link>
        <updated>2019-12-23T14:42:33.000Z</updated>
        <content type="html"><![CDATA[<p>又又又开始继续学习webpack啦！🏷</p>
<br/>
<p>本文记录有关webpack压缩🗜️相关的东西。</p>
<br/>
<blockquote>
<p>所见即所得，所见即所碍。</p>
</blockquote>
<p>start</p>
<br/>
<h3 id="javascript-压缩">JavaScript 压缩</h3>
<br/>
<p>内置了<code>uglifyjs-webpack-plugin</code>,所以默认打包出来的js文件已经被压缩。但是我们也可以自行安装该插件去开启并行压缩等。</p>
<br/>
<h3 id="css文件压缩">css文件压缩</h3>
<br/>
<p>使用 <code>optimize-css-assets-webpack-plugin</code>,同时使用<code>cssnano</code></p>
<pre><code>module.exports = {
    entry:{
        app:'./src/app.js',
        search:'./src/search.js'
    },
    output:{
        filename:'[name][chunkhash:8].js',
        path:__dirname+'/dist'
    }，
    plugin:[
        new OptimizeCSSAssentsPlugin({
            assetNameRegExp:/\.css$/g,
            cssProcessor:require('cssnano')
        })
    ]
}
</code></pre>
<p>匹配到所有的css文件，再通过<code>cssnano</code>对css进行压缩。</p>
<br/>
<h3 id="html文件压缩">html文件压缩</h3>
<br/>
<p>修改 <code>html-webpack-plugin</code>,设置压缩参数。</p>
<br/>
<pre><code>module.exports = {
    entry:{
        app:'./src/app.js',
        search:'./src/search.js'
    },
    output:{
        filename:'[name][chunkhash:8].js',
        path:__dirname+'/dist'
    },
    plugins:[
        new HtmlWebpackPlugin({
            template:path.join(__dirname,'src/search.html'),
            filename:'search.html',
            chunks:['search'],
            inject:true,
            minify:{
                html5:true,
                collapseWhitespace:true,
                preserveLineBreaks:false,
                minifyCSS:true,
                minifyJS:true,
                removeComments:false
            }
        })
    ]
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react-jsx 备忘]]></title>
        <id>https://heihei12305.github.io/post/react-jsx-bei-wang</id>
        <link href="https://heihei12305.github.io/post/react-jsx-bei-wang">
        </link>
        <updated>2019-12-19T07:29:19.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<h2 id="本文仅作备忘详情请查看官方文档">本文仅作备忘，详情请查看<a href="https://zh-hans.reactjs.org/docs/jsx-in-depth.html">官方文档</a></h2>
</blockquote>
<h3 id="用户定义的组件必须以大写字母开头">用户定义的组件必须以大写字母开头</h3>
<p>以小写字母开头的元素代表一个HTML内置组件，比如<code>&lt;div&gt;</code>或者<code>&lt;span&gt;</code>会生成对应的字符串<code>'div'</code>或者<code>'span'</code>传递给<code>React.createElement</code>（作为参数）。大写字母开头的元素则对应着在JavaScript引入或自定义的组件，如<code>&lt;Foo /&gt;</code>会编译为<code>React.createElement(Foo)</code>。</p>
<br/>
<p>我们建议使用大写字母开头命名自定义组件。如果你确实需要一个以小写字母开头的组件，则在JSX中使用它之前，必须将它赋值给一个小写字母开头的变量。</p>
<br/>
<p>例如，以下的代码将无法按预期进行：</p>
<pre><code>import React from 'react';

//错误！组件应该以大写字母开头：
function hello(props) {
	//正确！这种&lt;div&gt;的使用是合法的，因为div是一个有效的HTML标签
	return &lt;div&gt;Hello {props.toWhat}&lt;/div&gt;
}

function HelloWorld() {
	//错误！React会认为&lt;hello /&gt;是一个HTML标签，因为它没有以大写字母开头；
	return &lt;hello toWhat=&quot;World&quot; /&gt;
}
</code></pre>
<h3 id="属性展开">属性展开</h3>
<br/>
<p>如果你已经有了一个props对象，你可以使用展开运算符<code>...</code>来在JSX中传递整个props对象。以下两个组件是等价的：</p>
<pre><code>function App1() {
	return &lt;Greeting firstName=&quot;Ben&quot; lastName=&quot;Hector&quot;&gt;;
}
function App2() {
	const props = {firstName: 'Ben',lastName: 'Hector'};
	return &lt;Greeting {...props} /&gt;
}
</code></pre>
<p>你还可以选择只保留当前组件需要接收的props，并使用展开运算符将其他props传递下去。</p>
<pre><code>const Button = props =&gt; {
	const { kind,...other } = props;
	const className = kind === 'primary' ? 'primaryButton' : 'SecondaryButton';
	return &lt;button className={className} {...other} /&gt;;
};

const App = () =&gt; {
	return (
		&lt;div&gt;
			&lt;Button kind=&quot;primary&quot; onClick={() =&gt; console.log(&quot;clicked!&quot;)}&gt;
				Hello World!
			&lt;/Button&gt;
		&lt;/div&gt;
	);
};
</code></pre>
<h3 id="布尔类型null以及undefined将被忽略">布尔类型，Null以及Undefined将被忽略</h3>
<br/>
<p><code>false</code>,<code>null</code>,<code>undefined</code>.<code>true</code>是合法的子元素。但它们并不会被渲染。以下的JSX表达式渲染结果相同：</p>
<pre><code>&lt;div /&gt;

&lt;div&gt;&lt;/div&gt;

&lt;div&gt;{false}&lt;/div&gt;

&lt;div&gt;{null}&lt;/div&gt;

&lt;div&gt;{undefined}&lt;/div&gt;

&lt;div&gt;{true}&lt;/div&gt;
</code></pre>
<p>这有助于依据特定条件来渲染其他的React元素。例如，在以下JSX中，仅当<code>showHeader</code>为<code>true</code>时，才会渲染<code>&lt;Header /&gt;</code>组件：</p>
<pre><code>&lt;div&gt;
	{showHeader &amp;&amp; &lt;Header /&gt;}
	&lt;Content /&gt;
&lt;/div&gt;
</code></pre>
<p>值得注意的是一些&quot;falsy&quot;值，仍然会被React渲染。例如，以下代码并不会像你预期那样工作，因为当<code>props.messages</code>是空数组时，<code>0</code>仍然会被渲染：</p>
<pre><code>&lt;div&gt;
	{props.message.length &amp;&amp;
		&lt;MessageList messages={props.messages} /&gt;
	}
&lt;/div&gt;
</code></pre>
<p>要解决这个问题，确保 &amp;&amp; 之前的布尔表达式总是布尔值：</p>
<pre><code>&lt;div&gt;
	{props.message.length &gt;0  &amp;&amp;
		&lt;MessageList messages={props.messages} /&gt;
	}
&lt;/div&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react 学习笔记]]></title>
        <id>https://heihei12305.github.io/post/react-xue-xi-bi-ji</id>
        <link href="https://heihei12305.github.io/post/react-xue-xi-bi-ji">
        </link>
        <updated>2019-12-12T06:06:47.000Z</updated>
        <content type="html"><![CDATA[<p>备忘：</p>
<ul>
<li>
<p>脚手架 npm i create-react-app</p>
</li>
<li>
<p>创建 npx create-react-app [项目名]</p>
</li>
<li>
<p>pwa serviceWorker 离线应用</p>
</li>
<li>
<p>jsx 同时解析 html 和 js ： 遇到 &lt; 按照 html，遇到 { 按照 js</p>
</li>
<li>
<p>类名为 className，不能直接写class</p>
</li>
<li>
<p>fragment 在最外面套一层，不会影响布局（直接套div报错）</p>
</li>
<li>
<p>jsx return 为 html时，外面套上括号可支持换行</p>
</li>
<li>
<p>修改列表的值的时候，先用临时变量获取，然后修改，然后重新赋值。不允许直接操作原数据！虽然不报错，但是后期性能优化会遇到巨大障碍。</p>
</li>
<li>
<p>jsx的几个坑</p>
<ul>
<li>注释：<code>{/*第一次写注释*/}</code> 也可以写 // 不过需要换行，建议写上面那个</li>
<li>在jsx中css样式使用class要用className(防止与class混淆)</li>
<li>input中输入的value默认不会被解析为html，可使用 <code>dangerouslySetlnnerHTML = { {__html: item} }</code>来解析为html</li>
<li>label辅助标签，为了不与js中的for重复，需要使用htmlFor来代替for完成对标input的id功能。</li>
</ul>
</li>
<li>
<p>vscode 中的快速生成插件 simple react</p>
<ul>
<li>imr <code>import React from 'react'</code>;</li>
<li>imrc <code>import React,{ Component } from 'react'</code>;</li>
<li>impt <code>import Protypes from 'prop-types'</code>;</li>
<li>impc <code>import React, { PureComponent } from 'react'</code></li>
<li>cc</li>
</ul>
</li>
</ul>
<pre><code>class | extends Component {
	state = { | },
	render() {
		return ( | );
	}
}

export default |;
</code></pre>
<ul>
<li>ccc</li>
</ul>
<pre><code>class | extends Component {
	constructor(props) {
		super(props);
		this.state = { | };
	}
	render() {
		return ( | );
	}
}

export default |;
</code></pre>
<ul>
<li>sfc</li>
</ul>
<pre><code>const | = props =&gt; {
	return ( | );
};

export default |;
</code></pre>
<ul>
<li>cdm</li>
</ul>
<pre><code>componentDidMount() {
	|
}
</code></pre>
<ul>
<li>cwm</li>
</ul>
<pre><code>//WARING! To be deprecated in React v17. Use new lifecycle  static getDerivedStateFeomProps instead
componentWillReceiveProps(nextProps) {
	|
}
</code></pre>
<ul>
<li>gds</li>
</ul>
<pre><code>static getDerivedStateFromProps(nextProps, preStat) {
	|
}
</code></pre>
<ul>
<li>scu</li>
</ul>
<pre><code>shouldComponentUpdate(nextProps, nextState) {
	|
}
</code></pre>
<ul>
<li>cwu</li>
</ul>
<pre><code>//WARING! To be deprecated in React v17. Use componentDidUpdate instead
componentWillUpdate(nextProps, nextState) {
	|
}
</code></pre>
<ul>
<li>cdu</li>
</ul>
<pre><code>componentDidUpdate(prevProps, prevSatte) {
	|
}
</code></pre>
<ul>
<li>cwun</li>
</ul>
<pre><code>componentWillUnmount() {
	|
}
</code></pre>
<ul>
<li>cdc</li>
</ul>
<pre><code>componentDidCatch(error, info) {
	|
}
</code></pre>
<ul>
<li>gsdu</li>
</ul>
<pre><code>getSnapshotBeforeUpdate(prevProps, prevState) {
	|
}
</code></pre>
<ul>
<li>ss</li>
</ul>
<pre><code>this.setState({ | : | });
</code></pre>
<ul>
<li>ssf</li>
</ul>
<pre><code>this.setState(prevState =&gt; {
	return { | : prevState.| }
});
</code></pre>
<ul>
<li>ren</li>
</ul>
<pre><code>render() {
	return (
		|
	);
}
</code></pre>
<ul>
<li>rprop</li>
</ul>
<pre><code>class | extends Component {
	state = { | },
	render() {
		return this.props.render({
			|: this.state.|
		})
	}
}
</code></pre>
<ul>
<li>hoc</li>
</ul>
<pre><code>function | (|) {
	return class extends Component {
		constructor(props) {
			super(props);
		}
		
		render() {
			return &lt; | { ...this.props} /&gt;
		}
	};
}
</code></pre>
<ul>
<li>proto-type 可检验传值类型</li>
<li>必须传递 可用 <code>prototype.string.isrequired</code></li>
<li>组件第一次存在于DOM中，函数是不会被执行的，如果已经存在于DOM中，函数才会被执行。</li>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql  学习记录]]></title>
        <id>https://heihei12305.github.io/post/mysql-xue-xi-ji-lu</id>
        <link href="https://heihei12305.github.io/post/mysql-xue-xi-ji-lu">
        </link>
        <updated>2019-12-06T12:05:29.000Z</updated>
        <content type="html"><![CDATA[<p>mysql 文件夹  C:\Users\24241\Downloads\mysql-8.0\mysql-8.0.18-winx64\bin<br>
root 登陆  mysql -u root -p<br>
查询用户名密码  select host,user,authentication_string from mysql.user;<br>
创建数据库 CREATE DATABASE 数据库名;<br>
显示当前数据库 show databases;<br>
使用数据库  use 数据库名；</p>
<p>创建数据表  CREATE TABLE table_name (column_name column_type);<br>
删除数据表  DROP TABLE table_name ;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[webpack-文件指纹策略及将css单独提取出来]]></title>
        <id>https://heihei12305.github.io/post/webpack-wen-jian-zhi-wen-ce-lue</id>
        <link href="https://heihei12305.github.io/post/webpack-wen-jian-zhi-wen-ce-lue">
        </link>
        <updated>2019-11-26T23:31:50.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<h3 id="一般指的是打包后输出的文件名的后缀">一般指的是打包后输出的文件名的后缀。</h3>
</blockquote>
<h3 id="文件指纹如何生成">文件指纹如何生成？</h3>
<ul>
<li>Hash: 和整个项目的构建相关，只要项目文件有修改，整个项目构建的hash值就会更改。</li>
<li>Chunhash: 和webpack 打包的chunk有关，不同的entry会生成不同的chunkhash值。</li>
<li>Contenthash: 根据文件内容来定义hash，文件内容不变，则contenthash不变。</li>
</ul>
<br/>
### JS的文件指纹设置
<br/>
<p>设置output的filename，使用 [chunkhash]</p>
<pre><code>module.exports = {
	entry:{
		app:'./src/app.js',
		search:'./src/search.js'
	},
	output:{
		filename:'[name][chunkhash:8].js',
		path:__dirname+'/dist'
	}
};
</code></pre>
<h3 id="css文件的文件指纹设置">css文件的文件指纹设置</h3>
<br/>
<p>对于css文件，我们使用 contenthash<br/><br>
设置 MiniCssExtractPlugin 的 filename</p>
<pre><code>module.exports = {
	entry:{
		app:'./src/app.js',
		search:'./src/search.js'
	},
	output:{
		new MiniCssExtractPlugin({
			filename: `[name][contenthash:8].css`
		})
	}
}
</code></pre>
<h3 id="图片的文件指纹设置">图片的文件指纹设置</h3>
<br/>
<table>
<thead>
<tr>
<th style="text-align:center">占位符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[ext]</td>
<td style="text-align:center">资源后缀名</td>
</tr>
<tr>
<td style="text-align:center">[name]</td>
<td style="text-align:center">文件名称</td>
</tr>
<tr>
<td style="text-align:center">[path]</td>
<td style="text-align:center">文件的相对路径</td>
</tr>
<tr>
<td style="text-align:center">[folder]</td>
<td style="text-align:center">文件所在的文件夹</td>
</tr>
<tr>
<td style="text-align:center">[contenthash]</td>
<td style="text-align:center">文件的内容hash，默认是md5生成</td>
</tr>
<tr>
<td style="text-align:center">[hash]</td>
<td style="text-align:center">文件内容的Hash，默认是md5生成</td>
</tr>
<tr>
<td style="text-align:center">[emoji]</td>
<td style="text-align:center">一个随机的指代文件内容的emoj</td>
</tr>
</tbody>
</table>
<br/>
<pre><code>const path = require('path');

module.exports = {
	entry: './src/index.js',
	output:{
		filename: 'bundle.js',
		path:path.resolve(__dirname,'dist')
	},
	module:{
		rules:[
			{
				test:/\.(png|svg|jpg|gif)$/,
				use:[{
					loader:'file-loader',
					options:{
						name:'img/[name][hash:8].[ext]'
					}
				}]
			}
		]
	}
}

</code></pre>
<br/>
<p>为了将css独立出来</p>
<br/>
<p>安装 <code>mini-css-extract-plugin</code> 插件</p>
<br/>
<p>与<code>style-loader</code>插件互斥，因为 <code>mini-css-extract-plugin</code>为了将css样式提取出来，而<code>style-loader</code>则为了将样式写入header中。</p>
<br/>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[webpack文件监听及热更新原理]]></title>
        <id>https://heihei12305.github.io/post/webpack-wen-jian-jian-ting-ji-re-geng-xin-yuan-li</id>
        <link href="https://heihei12305.github.io/post/webpack-wen-jian-jian-ting-ji-re-geng-xin-yuan-li">
        </link>
        <updated>2019-11-23T11:40:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<h3 id="文件监听">文件监听</h3>
</blockquote>
<p>文件监听是在发现源码发生变化时，自动重新构建出新的输出文件。</p>
<br/>
<p>在webpack中开启监听模式，有两种方式：</p>
<ul>
<li>启动webpack命令时，带上 --watch 参数</li>
<li>在配置 webpack.config.js中设置 watch: true</li>
</ul>
<h3 id="唯一缺陷每次需要手动刷新浏览器">唯一缺陷：每次需要手动刷新浏览器</h3>
 <br/>
<blockquote>
<h3 id="文件监听原理分析">文件监听原理分析</h3>
</blockquote>
<p>轮询判断文件的最后编辑时间是否变化</p>
<br/>
<p>某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 aggregateTimeout</p>
<pre><code>module.export = {
	//默认为flase，也就是不开启
	watch: true,
	//只有开启监听模式，watchOptions才有意义
	watchOptions: {
		//默认为空，不监听的文件或者文件夹，支持正则匹配
		ignored: /node_modules/,
		//监听到变化发生后会等300ms再去执行，默认300ms
		aggregateTimeout: 300,
		//判断文件是否发生变化是通过不停询问系统指定文件有没有变化实现的，默认每秒问1000次
		poll:1000
	}
}
</code></pre>
<blockquote>
<h3 id="更好的方法-热更新wdswebpack-dev-server">更好的方法 热更新(wds)：webpack-dev-server</h3>
</blockquote>
<ul>
<li>方法1.</li>
</ul>
<br/>
<p>wds 通常与 HotModuleReplacementPlugin插件一起使用，wds的一个比较大的优势是，它没有磁盘的io,输出完之后放到内存中，而不是输出为文件，所以构建速度会有一个较大的优势。</p>
<br/>
<p>如果报错为 ： <code>'webpack-dev-server' 不是内部或外部命令，也不是可运行的程序 或批处理文件。</code>请先安装依赖：<code>yarn add webpack-dev-server -D</code></p>
<br/>
<ul>
<li>方法2.</li>
</ul>
<br/>
<p>WDM 将 webpack 输出的文件传输给服务器,使用于灵活的定制场景。</p>
<br/>
<pre><code>const express = require('express');
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-dev-middleware');

const app = express();
const config = require('./webpack.config.js');
const compiler = webpack(config);

app.use(webpackDevMiddleware(compiler,{
	publicPath: config.output.publicPath
}));

app.listen(3000,function(){
	console.log('Example app listening on post 3000\n')
})
</code></pre>
<p>在这种情况下，对webpack的配置控制会更加灵活</p>
<br/>
<blockquote>
<h3 id="webpack-热更新原理">webpack 热更新原理</h3>
</blockquote>
<ul>
<li>Webpack Compile: 将JS编译成Bundle</li>
<li>HMR Server： 将热更新的文件输出给HMR Runtime</li>
<li>Bundle server: 提供文件在浏览器的访问</li>
<li>HMR Runtime: 会被注入到浏览器，更新文件的变化</li>
<li>bundle.js 构建输出的文件</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6-你真的懂symbol吗❓🦝(上)]]></title>
        <id>https://heihei12305.github.io/post/es6-ni-zhen-de-dong-symbol-ma</id>
        <link href="https://heihei12305.github.io/post/es6-ni-zhen-de-dong-symbol-ma">
        </link>
        <updated>2019-11-16T01:44:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>所见即所得，所见即所碍</p>
</blockquote>
<br/>
<blockquote>
<h3 id="从一个问题引入你知道现在js中有几种基本数据类型吗分别是什么呢">从一个问题引入，你知道现在js中有几种基本数据类型吗？分别是什么呢？</h3>
</blockquote>
<p>作为一道经典面试题，相信各位肯定脱口就来：字符串型，数字型，布尔型，null,undefined,es6新引入的symbol，还处于ECMAScript 标准化过程中的 第三阶段 的bigInt<br/></p>
<p>那么symbol到底是什么呢？<br/></p>
<p>接下来，我们会开始进入symbol的世界。</p>
<br/>
<p>大概目录：</p>
<ul>
<li>symbol基础</li>
<li>well-konw symbol 暴露内部操作</li>
<li>元编程</li>
</ul>
<p>内容主要来自</p>
<br/>
<ul>
<li>深入理解es6</li>
<li>你不知道的javaScript下</li>
<li><a href="https://juejin.im/post/5a0e65c1f265da430702d6b9">[译]ES6 中的元编程：第一部分 —— Symbol，了不起的 Symbol</a></li>
</ul>
<h2 id="symbol基础">symbol基础</h2>
<br/>
<h3 id="symbol-是完全唯一的">symbol 是完全唯一的</h3>
<p>在默认情况下，每一个新创建的Symbol都有一个完全唯一的值。如果你新创建了一个Symbol，在JS引擎内部，就会创建一个全新的值。</p>
<br/>
<p>Symbol函数接受一个可选的参数，其可以让你添加一段文本描述即将创建的Symbol，这段描述不可用于属性访问，但是建议你在每一次创建 Symbol 时都能加这样一段描述，以便于阅读代码和调试Symbol程序。</p>
<pre><code>let firstName = Symbol(&quot;first name&quot;);
let person = { };

person[firstName] = 'Nicholas';

console.log(&quot;first name&quot; in person);  //false
console.log(person[firstName]); //'Nicholas'
console.log(firstName); //&quot;Symbol(firstName)&quot;
</code></pre>
<p>Symbol 的描述被存储在内部的[[Description]]属性中，只有当调用Symbol的toString()方法时才可以读取这个属性。在执行 <code>console.log()</code>时，隐式调用了 firstName 的 toString() 方法，所以它的描述会被打印到日志中，但不能直接在代码里访问[[Description]]</p>
<br/>
<h3 id="symbol-判断">symbol 判断</h3>
<p>因为symbol是基本数据类型，所以判断symbol首选也最准确的检测方式是 typeof</p>
<pre><code>console.log(typeof firstName );//'symbol'
</code></pre>
<h3 id="symbol共享结构">symbol共享结构</h3>
<br/>
<p>有时候我们可能希望在不同的代码中共享同一个Symbol，例如，在你的应用中有两种不同的对象类型，但是你希望它们使用同一个Symbol 属性来表示一个独特的标识符。一般而言，在很大的代码库中或跨文件追踪 Symbol 非常困难而且容易出错，出于这些原因，ECMAScript 6 提出了一个可以随时访问的全局 Symbol 注册表。</p>
<br/>
<p>如果想创建一个可共享的Symbole,要使用<code>Symbol.for()方法</code>。它只接受一个参数，也就是即将创建的 Symbol 的字符串标识符，这个参数同样也被用于Symbol的描述。</p>
<br/>
<pre><code>let uid = Symbol.for(&quot;uid&quot;);
let object = {};

object[uid] = &quot;123456&quot;;

console.log(object[uid]); //'123456'
console.log(uid)
</code></pre>
<p>Symbol.for()方法首先在全局 Symbol 注册表中搜索键为&quot;uid&quot;的Symbol是否存在，如果存在，直接返回已有的 Symbol ;否则，创建一个新的Symbol,并使用这个键在Symbol全局注册表中注册，随即返回新创建的Symbol。</p>
<br/>
<p>后续再传入同样的键调用 Symbol.for() 会返回相同的Symbol</p>
<pre><code>let uid = Symbol.for(&quot;uid&quot;);
let object = {};
object[uid] = &quot;123456&quot;;

let uid2 = Symbol.for('uid');

console.log(uid === uid2); // true
</code></pre>
<p>还有一个与 Symbol 共享有关的特性：可以使用 Symbol.keyFor()方法在Symbol全局注册表中检索与Symbol有关的键。</p>
<pre><code>let uid = Symbol.for(&quot;uid&quot;);
let object = {};

object[uid] = &quot;123456&quot;;
let uid2 = Symbol.for('uid');

console.log(Symbol.keyFor(uid));//&quot;uid&quot;
console.log(Symbol.keyFor(uid2));//&quot;uid&quot;
console.log(Symbol.keyFor(uid3));//&quot;undefined&quot;
</code></pre>
<br/>
<p>symbol全局注册表是一个类似全局作用域的共享环境，也就是说你不能假设目前环境中存在哪些键。当使用第三方组件时，尽量使用Symbol键的命名空间以减少命名冲突，也即加上前缀。额外注意的一点是：这个注册中心是跨域的，意味着 iframe 或者sevice worker 中的 Symbol 会与当前 frame Symbol 相等。</p>
<br/>
<h2 id="well-konw-symbol-暴露内部操作">well-konw symbol 暴露内部操作</h2>
<p>ECMAScript5 的一个中心主旨是将JavaScript中的一些“神奇”的部分暴露出来，并详尽定义了这些开发者们中当时模拟不了的功能。ECMAScript6延续了这个传统，新标准中主要通过中原型链上定义了与Symbol相关的属性来暴露更多的语言内部逻辑。</p>
<br/>
<p>包括</p>
<ul>
<li>Symbol.hasInstance 一个在执行instanceof 时调用的内部方法，用于检测对象的继承信息。</li>
<li>Symbol.isConcatSpreadable 一个布尔值，用于表示当传递一个集合作为<code>Array.prototype.concat()</code>方法的参数时，是否应该将集合内的元素规整到同级。</li>
<li>Symbol.iterator 一个返回迭代器的方法。</li>
<li>Symbol.match 一个在调用<code>String.prototype.match()</code>方法时调用的方法，用于比较字符串。</li>
<li>Symbol.replace 一个在调用 <code>String.prototype.replace()</code>方法时调用的方法，同于替换字符串的子串。</li>
<li>Symbol.search 一个在调用<code>String.prototype.search()</code>方法时调用的方法，用于字符串中定位子串。</li>
<li>Symbol.split 一个在调用<code>String.prototype.split()</code>方法时调用的方法，用于分割字符串。</li>
<li>Symbol.toPrimitive 一个返回对象原始值的方法。</li>
<li>Symbol.toStringTag 一个在调用 <code>Object.prototype.toString()</code>方法时使用的字符串，用于创建对象描述。</li>
<li>Symbol.unscopables 一个定义了一些不可被with语句引用的对象属性名称的对象集合。</li>
</ul>
<p>重写一个由<code>well-known Symbol</code>定义的方法，会导致对象内部的默认行为被改变，从而一个普通对象会变成一个奇异对象（exotic object）。但实际上其不会对你的代码产生任何影响，只是在规范中描述对象的方式改变了。</p>
<br/>
<h3 id="symbolhasinstance-方法">Symbol.hasInstance 方法</h3>
<br/>
<p>每一个函数中都有一个<code>Symbol.hasInstance</code>方法，用于确定对象是否为函数的实例。该方法在<code>Function.prototype</code>中定义，所以所有的函数都继承了<code>instance</code>属性的默认行为。为了确保      <code>Symbol.hasInstance</code>不会被意外重写，该方法被定义为不可写，不可配置并且不可枚举。</p>
<br/>
<p><code>Symbol.hasInstance</code>方法只接受一个参数，即要检查的值。如果传入的值是函数的实例，则返回true。</p>
<pre><code>obj instanceof Array;
</code></pre>
<p>等同于</p>
<pre><code>Array[Symbol.hasInstance](obj);
</code></pre>
<p>本质上，ECMAScript6只是将instanceof操作符重新定义为此方法的简写语法。现在引入方法调用后，就可以随意改变instanceof的运行方式了。</p>
<br/>
<p>举个🌰，假设你想定义☝️无实例的函数，就可以将<code>Symbol.hasInstance</code>的返回值硬编码为false。</p>
<pre><code>function MyObject() {
    //空函数
}

Object.defineProperty(MyObject,Symbole.hasInstance,{
    value: function(v) {
        return false;
    }
});

let obj = new MyObject();

console.log(obj instanceof MyObject);   //false
</code></pre>
<p>只有通过<code>Object.defineProperty()</code>方法才能够改写一个不可写属性，上面的示例调用方法来改写<code>Symbol.hasInstance</code>,为其定义一个总是返回false的新函数，即使obj实际上确实是MyObject类的实例，在调用过<code>Object.defineProperty()</code>方法之后，instance运算符返回的也是false。</p>
<br/>
<p>当然，也可以基于任意条件，通过值检查来确定被检查的是否为实例。举个🌰，可以将1～100的数字定义为一个特殊数字类型的实例，具体实现的代码如下：</p>
<pre><code>function SpecialNumber() {
    // 空函数
}

Object.defineProperty(SpecialNumber,Symbol.hasInstance,{
    value: function(v) {
        return (v instance Number) &amp;&amp; (V &gt;= 1 &amp;&amp; V &lt;= 100);
    }
});

var two = new Number(2),
    zero = new Number(0);
console.log(two instanceof SpecialNumber); //true
console.log(zero instanceof SpecialNumber); //false
</code></pre>
<blockquote>
<p>也可以重写所有的内建函数（例如Date和Error函数）默认的Symbol.hasInstance属性。但是这样做的后果是代码的运行结果变得不可预期而且有可能令人感到😖，所以我们不推荐你这么做，最好的做法是，只在必要的情况下改写你自己声明的函数的Symbol.hasInstance 属性。</p>
</blockquote>
<h3 id="symbolisconcatspreadable属性">Symbol.isConcatSpreadable属性</h3>
<br/>
<p>JavaScript数组的<code>concat()</code>方法被设计用于拼接两个数组，使用方法：</p>
<pre><code>let color1 = ['red','green'],
    color2 = color1.concat(['blue','black']);

    console.log(color2.length);  //4
    console.log(color2); //['red','green','blue','black']
</code></pre>
<p><code>concat()</code>方法也可以接受非数组参数，此时该方法只会将这些参数逐一添加到数组末尾</p>
<pre><code>let color1 = ['red','green'],
    color2 = color1.concat(['blue','black'],'brown');

    console.log(color2.length);  //5
    console.log(color2); //['red','green','blue','black','brown']
</code></pre>
<p>为什么数组参数就要区分对待呢？JavaScript规范声明，凡是传入数组参数，就会自动将它们分解为独立元素。在ECMAScript6标准以前，我们根本无法调整这个特性。<br>
<br/><br>
Symbol.isConcatSpreadable 属性是一个布尔值，如果该属性值为true，则表明对象有length属性和数字键，故它的数值型属性值应该被独立添加到<code>concat()</code>调用结果中。它与其他well-known Symbol不同的是，这个Symbol属性默认情况下不会出现在标准对象中，它只是一个可选属性，用于增强作用于特定对象类型的<code>concat()</code>方法的功能，有效简化其默认特性。可以通过以下方法，定义一个<code>在concat()</code>调用中与数组行为相近的新类型。</p>
<pre><code>let collection = {
    0: 'Hello',
    1: 'world',
    length:2,
    [Symbol.isConcatSpreadable]: true
};

let messages = [ 'Hi' ].concat(collection);

console.log(messages); //['Hi,'Hello','world']
</code></pre>
<p>在这个示例中，定义来一个类数组对象 collection: 它有一个length属性，还有两个数字键，symbol.isConcatSpreadable属性为true表明属性值应当被当作独立元素添加到数组中。</p>
<blockquote>
<p>也可以在派生数组子类时将Symbol.isCaoncatSpreadable设置为false,从而防止元素在调用<code>concat()</code>方法时被分解。</p>
</blockquote>
<h3 id="正则相关的symbolmatchsymbolreplacesymbolsearch和symbolsplit属性">正则相关的Symbol.match,Symbol.replace,Symbol.search和Symbol.split属性</h3>
<br/>
<p>在JavaScript中，字符串与正则表达式通常一起出现，尤其是字符串类型的几个方法，可以接受正则表达式作为参数：</p>
<ul>
<li><code>match(regex)</code> 确定给定字符串是否匹配正则表达式regex</li>
<li><code>replace(regex,replacement)</code> 将字符串中匹配正则表达式regex的部分替换为replacement</li>
<li><code>search(regex)</code> 在字符串中定位匹配正则表达式regex的位置索引</li>
<li><code>split(regex)</code> 按照匹配正则表达式regex的元素将字符串分切，并将结果存入数组中。</li>
</ul>
<p>中ECMAScript6中，定义了与上述4个方法相对应的4个Symbol,将语言内建的RegExp对象的原生特性完全外包出来。</p>
<br/>
<ul>
<li>Symbol.match 接受一个字符串类型的参数，如果匹配成功则返回匹配元素的数组，否则返回null。</li>
<li>Symbol.replace 接受一个字符串类型的参数和一个替换用的字符串，最终依然返回一个字符串。</li>
<li>Symbol.search 接受一个字符串参数，如果匹配到内容，则返回数字类型的索引位置，否则返回-1。</li>
<li>Symbol.split 接受一个字符串参数，根据匹配内容将字符串分解，并返回一个包含分解后片段的数组。</li>
</ul>
<p>如果可以在对象中定义这些属性，即使不使用正则表达式和以正则表达式为参的方法也可以在对象中实现模式匹配。下面的示例将展示Symbol的实际用法：</p>
<pre><code>//实际上等价于 /^.{10}$/
let hasLengthOf10 = {
    [Symbol.match]: function(value) {
        return value.length === 10 ? [value] : null;
    },
    [Symbol.replace]: function(value, replacement) {
        return value.length === 10 ? replacement : value;
    },
    [Symbol.search]: function(value) {
        return value.length === 10 ? 0 : -1;
    },
    [Symbol.split]: function(value) {
        return value.length === 10 ? [, ] : [value];
    }
};

let message1 = 'Hello world', //11个字符
    message2 = 'Hello Jshn'; //10个字符

let match1 = message1.match(hasLengthOf10),
    match2 = message2.match(hasLengthOf10);

console.log(match1,match2); //null [&quot;Hello John&quot;]

let replace1 = message1.replace(hasLengthOf10),
    replace2 = message2.replace(hasLengthOf10);

console.log(replace1,replace2); //'Hello world' undefined

let search1 = message1.search(hasLengthOf10),
    search2 = message2.search(hasLengthOf10);

console.log(search1,search2); //-1 0

let split1 = message1.split(hasLengthOf10),
    split2 = message2.split(hasLengthOf10);

console.log(split1,split2); //['Hello world'] [empty]
</code></pre>
<h3 id="symboltoprimitive-方法">Symbol.toPrimitive 方法</h3>
<br/>
<p>在JavaScript引擎中，当执行特定操作时，经常会尝试将对象转化为原始值，例如，比较一个字符串和一个对象，如果使用双等号（==）运算符，对象会在比较操作执行前被转化为一个原始值。到底使用哪一个原始值以前由内部决定的，但在ECMAScript6的标准中，通过Symbol,toPrimitive方法可以更改那个暴露出来的值。</p>
<br/>
<p>Symbol.toPrimitive 方法被定义在每一个标准类型的原型上，并且规定当对象被转换为原始值时应当执行的操作。每当执行原始值转换时，总会调用Symbol.Primitive方法并传入一个值作为参数，这个值在规范中被称做类型提示（hint）。类型提示参数的值只有三种选择：“number”,&quot;string&quot;或“default”，传递这些参数时，Symbol.toprimitive返回的分别是：数字，字符串或无类型偏好的值。</p>
<br/>
<p>对于大多数标准对象，数字模式有以下特性，根据优先级的顺序排列如下：</p>
<ol>
<li>调用<code>valueOf()</code>方法，如果结果为原始值，则返回。</li>
<li>否则，调用<code>toString()方法</code>，如果结果为原始值，则返回。</li>
<li>如果再无可选的值，则抛出错误。</li>
</ol>
<p>同样，对于大多数标准对象，字符串模式有以下优先级排序：</p>
<ol>
<li>调用<code>toString()</code>方法，如果结果为原始值，则返回。</li>
<li>否则，调用<code>valueOf()</code>方法，如果结果为原始值，则返回。</li>
<li>如果再无可选的值，则抛出错误。</li>
</ol>
<p>在大多数情况下，标准对象会将默认模式按数字模式处理（除了Date对象，在这种情况下，会讲默认模式按字符串模式处理）。如果自定义 Symbol.toPrimitive方法，则可以覆盖这些默认的强制转换特性。</p>
<br/>
<blockquote>
<p>默认模式只用于==运算，+元算及给Date构造函数传递一个参数时。在大多数操作中，使用的都是字符串模式或数字模式。</p>
</blockquote>
<p>如果要覆写默认的转化特性，可以将函数的Symbol.toPrimitive属性赋值为一个新的函数，举个🌰：</p>
<pre><code>function Temperature(degrees) {
    this.degrees = degrees;
}

Temperature.prototype[Symbol.toPrimitive] = function(hint) {
    switch(hint) {
        case &quot;string&quot;:
            return this.degrees + &quot;\u00b0&quot;; 
        case &quot;number&quot;:
            return this.degrees;
        case &quot;default&quot;:
            return this.degrees + &quot; degrees&quot;;
    }
}

var freezing = new Temperature(32);

console.log(freezing + &quot;!&quot;);   //&quot;32 degrees!&quot;
console.log(freezing / 2);     //16
console.log(String(freezing))  //&quot;32°&quot;
</code></pre>
<p>新的方法根据参数hint指定的模式返回不同的值（参数hint由JavaScript引擎传入）。在字符串模式下，<code>Temperature()</code>函数返回Unicode的温度符号；在数字模式下，返回相应的数值；在默认模式下，将degress这个单词添加到数字后。</p>
<br/>
<p>每一条<code>console.log()</code>语句将触发不同的hint参数值。+运算符触发默认模式，hint被设置为“default”；/运算符触发数字模式，hint被设置为“number”；<code>String()</code>函数触发字符串模式，hint被设置为“string”。针对三种模式返回的值时可行的，但是更常见的做法是，将默认模式设置成与字符串模式或数字模式相同的处理逻辑。</p>
<br/>
<blockquote>
<p>🔒好像有点长了呢（才不是我不想再打字了），剩下部分的留给下吧！</p>
</blockquote>
<br/>
<p>to be continued🖋</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DOMAPI完全整理]]></title>
        <id>https://heihei12305.github.io/post/domapi-wan-quan-zheng-li</id>
        <link href="https://heihei12305.github.io/post/domapi-wan-quan-zheng-li">
        </link>
        <updated>2019-11-08T05:58:31.000Z</updated>
        <content type="html"><![CDATA[<p>asda，待整理</p>
]]></content>
    </entry>
</feed>