<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://heihei12305.github.io</id>
    <title>heihei12305</title>
    <updated>2019-12-22T03:36:50.460Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://heihei12305.github.io"/>
    <link rel="self" href="https://heihei12305.github.io/atom.xml"/>
    <subtitle>所见即所得，所见即所碍</subtitle>
    <logo>https://heihei12305.github.io/images/avatar.png</logo>
    <icon>https://heihei12305.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, heihei12305</rights>
    <entry>
        <title type="html"><![CDATA[react-jsx 备忘]]></title>
        <id>https://heihei12305.github.io/post/react-jsx-bei-wang</id>
        <link href="https://heihei12305.github.io/post/react-jsx-bei-wang">
        </link>
        <updated>2019-12-19T07:29:19.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<h2 id="本文仅作备忘详情请查看官方文档">本文仅作备忘，详情请查看<a href="https://zh-hans.reactjs.org/docs/jsx-in-depth.html">官方文档</a></h2>
</blockquote>
<h3 id="用户定义的组件必须以大写字母开头">用户定义的组件必须以大写字母开头</h3>
<p>以小写字母开头的元素代表一个HTML内置组件，比如<code>&lt;div&gt;</code>或者<code>&lt;span&gt;</code>会生成对应的字符串<code>'div'</code>或者<code>'span'</code>传递给<code>React.createElement</code>（作为参数）。大写字母开头的元素则对应着在JavaScript引入或自定义的组件，如<code>&lt;Foo /&gt;</code>会编译为<code>React.createElement(Foo)</code>。</p>
<br/>
<p>我们建议使用大写字母开头命名自定义组件。如果你确实需要一个以小写字母开头的组件，则在JSX中使用它之前，必须将它赋值给一个小写字母开头的变量。</p>
<br/>
<p>例如，以下的代码将无法按预期进行：</p>
<pre><code>import React from 'react';

//错误！组件应该以大写字母开头：
function hello(props) {
	//正确！这种&lt;div&gt;的使用是合法的，因为div是一个有效的HTML标签
	return &lt;div&gt;Hello {props.toWhat}&lt;/div&gt;
}

function HelloWorld() {
	//错误！React会认为&lt;hello /&gt;是一个HTML标签，因为它没有以大写字母开头；
	return &lt;hello toWhat=&quot;World&quot; /&gt;
}
</code></pre>
<h3 id="属性展开">属性展开</h3>
<br/>
<p>如果你已经有了一个props对象，你可以使用展开运算符<code>...</code>来在JSX中传递整个props对象。以下两个组件是等价的：</p>
<pre><code>function App1() {
	return &lt;Greeting firstName=&quot;Ben&quot; lastName=&quot;Hector&quot;&gt;;
}
function App2() {
	const props = {firstName: 'Ben',lastName: 'Hector'};
	return &lt;Greeting {...props} /&gt;
}
</code></pre>
<p>你还可以选择只保留当前组件需要接收的props，并使用展开运算符将其他props传递下去。</p>
<pre><code>const Button = props =&gt; {
	const { kind,...other } = props;
	const className = kind === 'primary' ? 'primaryButton' : 'SecondaryButton';
	return &lt;button className={className} {...other} /&gt;;
};

const App = () =&gt; {
	return (
		&lt;div&gt;
			&lt;Button kind=&quot;primary&quot; onClick={() =&gt; console.log(&quot;clicked!&quot;)}&gt;
				Hello World!
			&lt;/Button&gt;
		&lt;/div&gt;
	);
};
</code></pre>
<h3 id="布尔类型null以及undefined将被忽略">布尔类型，Null以及Undefined将被忽略</h3>
<br/>
<p><code>false</code>,<code>null</code>,<code>undefined</code>.<code>true</code>是合法的子元素。但它们并不会被渲染。以下的JSX表达式渲染结果相同：</p>
<pre><code>&lt;div /&gt;

&lt;div&gt;&lt;/div&gt;

&lt;div&gt;{false}&lt;/div&gt;

&lt;div&gt;{null}&lt;/div&gt;

&lt;div&gt;{undefined}&lt;/div&gt;

&lt;div&gt;{true}&lt;/div&gt;
</code></pre>
<p>这有助于依据特定条件来渲染其他的React元素。例如，在以下JSX中，仅当<code>showHeader</code>为<code>true</code>时，才会渲染<code>&lt;Header /&gt;</code>组件：</p>
<pre><code>&lt;div&gt;
	{showHeader &amp;&amp; &lt;Header /&gt;}
	&lt;Content /&gt;
&lt;/div&gt;
</code></pre>
<p>值得注意的是一些&quot;falsy&quot;值，仍然会被React渲染。例如，以下代码并不会像你预期那样工作，因为当<code>props.messages</code>是空数组时，<code>0</code>仍然会被渲染：</p>
<pre><code>&lt;div&gt;
	{props.message.length &amp;&amp;
		&lt;MessageList messages={props.messages} /&gt;
	}
&lt;/div&gt;
</code></pre>
<p>要解决这个问题，确保 &amp;&amp; 之前的布尔表达式总是布尔值：</p>
<pre><code>&lt;div&gt;
	{props.message.length &gt;0  &amp;&amp;
		&lt;MessageList messages={props.messages} /&gt;
	}
&lt;/div&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react 学习笔记]]></title>
        <id>https://heihei12305.github.io/post/react-xue-xi-bi-ji</id>
        <link href="https://heihei12305.github.io/post/react-xue-xi-bi-ji">
        </link>
        <updated>2019-12-12T06:06:47.000Z</updated>
        <content type="html"><![CDATA[<p>备忘：</p>
<ul>
<li>
<p>脚手架 npm i create-react-app</p>
</li>
<li>
<p>创建 npx create-react-app [项目名]</p>
</li>
<li>
<p>pwa serviceWorker 离线应用</p>
</li>
<li>
<p>jsx 同时解析 html 和 js ： 遇到 &lt; 按照 html，遇到 { 按照 js</p>
</li>
<li>
<p>类名为 className，不能直接写class</p>
</li>
<li>
<p>fragment 在最外面套一层，不会影响布局（直接套div报错）</p>
</li>
<li>
<p>jsx return 为 html时，外面套上括号可支持换行</p>
</li>
<li>
<p>修改列表的值的时候，先用临时变量获取，然后修改，然后重新赋值。不允许直接操作原数据！虽然不报错，但是后期性能优化会遇到巨大障碍。</p>
</li>
<li>
<p>jsx的几个坑</p>
<ul>
<li>注释：<code>{/*第一次写注释*/}</code> 也可以写 // 不过需要换行，建议写上面那个</li>
<li>在jsx中css样式使用class要用className(防止与class混淆)</li>
<li>input中输入的value默认不会被解析为html，可使用 <code>dangerouslySetlnnerHTML = { {__html: item} }</code>来解析为html</li>
<li>label辅助标签，为了不与js中的for重复，需要使用htmlFor来代替for完成对标input的id功能。</li>
</ul>
</li>
<li>
<p>vscode 中的快速生成插件 simple react</p>
<ul>
<li>imr <code>import React from 'react'</code>;</li>
<li>imrc <code>import React,{ Component } from 'react'</code>;</li>
<li>impt <code>import Protypes from 'prop-types'</code>;</li>
<li>impc <code>import React, { PureComponent } from 'react'</code></li>
<li>cc</li>
</ul>
</li>
</ul>
<pre><code>class | extends Component {
	state = { | },
	render() {
		return ( | );
	}
}

export default |;
</code></pre>
<ul>
<li>ccc</li>
</ul>
<pre><code>class | extends Component {
	constructor(props) {
		super(props);
		this.state = { | };
	}
	render() {
		return ( | );
	}
}

export default |;
</code></pre>
<ul>
<li>sfc</li>
</ul>
<pre><code>const | = props =&gt; {
	return ( | );
};

export default |;
</code></pre>
<ul>
<li>cdm</li>
</ul>
<pre><code>componentDidMount() {
	|
}
</code></pre>
<ul>
<li>cwm</li>
</ul>
<pre><code>//WARING! To be deprecated in React v17. Use new lifecycle  static getDerivedStateFeomProps instead
componentWillReceiveProps(nextProps) {
	|
}
</code></pre>
<ul>
<li>gds</li>
</ul>
<pre><code>static getDerivedStateFromProps(nextProps, preStat) {
	|
}
</code></pre>
<ul>
<li>scu</li>
</ul>
<pre><code>shouldComponentUpdate(nextProps, nextState) {
	|
}
</code></pre>
<ul>
<li>cwu</li>
</ul>
<pre><code>//WARING! To be deprecated in React v17. Use componentDidUpdate instead
componentWillUpdate(nextProps, nextState) {
	|
}
</code></pre>
<ul>
<li>cdu</li>
</ul>
<pre><code>componentDidUpdate(prevProps, prevSatte) {
	|
}
</code></pre>
<ul>
<li>cwun</li>
</ul>
<pre><code>componentWillUnmount() {
	|
}
</code></pre>
<ul>
<li>cdc</li>
</ul>
<pre><code>componentDidCatch(error, info) {
	|
}
</code></pre>
<ul>
<li>gsdu</li>
</ul>
<pre><code>getSnapshotBeforeUpdate(prevProps, prevState) {
	|
}
</code></pre>
<ul>
<li>ss</li>
</ul>
<pre><code>this.setState({ | : | });
</code></pre>
<ul>
<li>ssf</li>
</ul>
<pre><code>this.setState(prevState =&gt; {
	return { | : prevState.| }
});
</code></pre>
<ul>
<li>ren</li>
</ul>
<pre><code>render() {
	return (
		|
	);
}
</code></pre>
<ul>
<li>rprop</li>
</ul>
<pre><code>class | extends Component {
	state = { | },
	render() {
		return this.props.render({
			|: this.state.|
		})
	}
}
</code></pre>
<ul>
<li>hoc</li>
</ul>
<pre><code>function | (|) {
	return class extends Component {
		constructor(props) {
			super(props);
		}
		
		render() {
			return &lt; | { ...this.props} /&gt;
		}
	};
}
</code></pre>
<ul>
<li>proto-type 可检验传值类型</li>
<li>必须传递 可用 <code>prototype.string.isrequired</code></li>
<li>组件第一次存在于DOM中，函数是不会被执行的，如果已经存在于DOM中，函数才会被执行。</li>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql  学习记录]]></title>
        <id>https://heihei12305.github.io/post/mysql-xue-xi-ji-lu</id>
        <link href="https://heihei12305.github.io/post/mysql-xue-xi-ji-lu">
        </link>
        <updated>2019-12-06T12:05:29.000Z</updated>
        <content type="html"><![CDATA[<p>mysql 文件夹  C:\Users\24241\Downloads\mysql-8.0\mysql-8.0.18-winx64\bin<br>
root 登陆  mysql -u root -p<br>
查询用户名密码  select host,user,authentication_string from mysql.user;<br>
创建数据库 CREATE DATABASE 数据库名;<br>
显示当前数据库 show databases;<br>
使用数据库  use 数据库名；</p>
<p>创建数据表  CREATE TABLE table_name (column_name column_type);<br>
删除数据表  DROP TABLE table_name ;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[webpack-文件指纹策略及将css单独提取出来]]></title>
        <id>https://heihei12305.github.io/post/webpack-wen-jian-zhi-wen-ce-lue</id>
        <link href="https://heihei12305.github.io/post/webpack-wen-jian-zhi-wen-ce-lue">
        </link>
        <updated>2019-11-26T23:31:50.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<h3 id="一般指的是打包后输出的文件名的后缀">一般指的是打包后输出的文件名的后缀。</h3>
</blockquote>
<h3 id="文件指纹如何生成">文件指纹如何生成？</h3>
<ul>
<li>Hash: 和整个项目的构建相关，只要项目文件有修改，整个项目构建的hash值就会更改。</li>
<li>Chunhash: 和webpack 打包的chunk有关，不同的entry会生成不同的chunkhash值。</li>
<li>Contenthash: 根据文件内容来定义hash，文件内容不变，则contenthash不变。</li>
</ul>
<br/>
### JS的文件指纹设置
<br/>
<p>设置output的filename，使用 [chunkhash]</p>
<pre><code>module.exports = {
	entry:{
		app:'./src/app.js',
		search:'./src/search.js'
	},
	output:{
		filename:'[name][chunkhash:8].js',
		path:__dirname+'/dist'
	}
};
</code></pre>
<h3 id="css文件的文件指纹设置">css文件的文件指纹设置</h3>
<br/>
<p>对于css文件，我们使用 contenthash<br/><br>
设置 MiniCssExtractPlugin 的 filename</p>
<pre><code>module.exports = {
	entry:{
		app:'./src/app.js',
		search:'./src/search.js'
	},
	output:{
		new MiniCssExtractPlugin({
			filename: `[name][contenthash:8].css`
		})
	}
}
</code></pre>
<h3 id="图片的文件指纹设置">图片的文件指纹设置</h3>
<br/>
<table>
<thead>
<tr>
<th style="text-align:center">占位符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[ext]</td>
<td style="text-align:center">资源后缀名</td>
</tr>
<tr>
<td style="text-align:center">[name]</td>
<td style="text-align:center">文件名称</td>
</tr>
<tr>
<td style="text-align:center">[path]</td>
<td style="text-align:center">文件的相对路径</td>
</tr>
<tr>
<td style="text-align:center">[folder]</td>
<td style="text-align:center">文件所在的文件夹</td>
</tr>
<tr>
<td style="text-align:center">[contenthash]</td>
<td style="text-align:center">文件的内容hash，默认是md5生成</td>
</tr>
<tr>
<td style="text-align:center">[hash]</td>
<td style="text-align:center">文件内容的Hash，默认是md5生成</td>
</tr>
<tr>
<td style="text-align:center">[emoji]</td>
<td style="text-align:center">一个随机的指代文件内容的emoj</td>
</tr>
</tbody>
</table>
<br/>
<pre><code>const path = require('path');

module.exports = {
	entry: './src/index.js',
	output:{
		filename: 'bundle.js',
		path:path.resolve(__dirname,'dist')
	},
	module:{
		rules:[
			{
				test:/\.(png|svg|jpg|gif)$/,
				use:[{
					loader:'file-loader',
					options:{
						name:'img/[name][hash:8].[ext]'
					}
				}]
			}
		]
	}
}

</code></pre>
<br/>
<p>为了将css独立出来</p>
<br/>
<p>安装 <code>mini-css-extract-plugin</code> 插件</p>
<br/>
<p>与<code>style-loader</code>插件互斥，因为 <code>mini-css-extract-plugin</code>为了将css样式提取出来，而<code>style-loader</code>则为了将样式写入header中。</p>
<br/>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[webpack文件监听及热更新原理]]></title>
        <id>https://heihei12305.github.io/post/webpack-wen-jian-jian-ting-ji-re-geng-xin-yuan-li</id>
        <link href="https://heihei12305.github.io/post/webpack-wen-jian-jian-ting-ji-re-geng-xin-yuan-li">
        </link>
        <updated>2019-11-23T11:40:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<h3 id="文件监听">文件监听</h3>
</blockquote>
<p>文件监听是在发现源码发生变化时，自动重新构建出新的输出文件。</p>
<br/>
<p>在webpack中开启监听模式，有两种方式：</p>
<ul>
<li>启动webpack命令时，带上 --watch 参数</li>
<li>在配置 webpack.config.js中设置 watch: true</li>
</ul>
<h3 id="唯一缺陷每次需要手动刷新浏览器">唯一缺陷：每次需要手动刷新浏览器</h3>
 <br/>
<blockquote>
<h3 id="文件监听原理分析">文件监听原理分析</h3>
</blockquote>
<p>轮询判断文件的最后编辑时间是否变化</p>
<br/>
<p>某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 aggregateTimeout</p>
<pre><code>module.export = {
	//默认为flase，也就是不开启
	watch: true,
	//只有开启监听模式，watchOptions才有意义
	watchOptions: {
		//默认为空，不监听的文件或者文件夹，支持正则匹配
		ignored: /node_modules/,
		//监听到变化发生后会等300ms再去执行，默认300ms
		aggregateTimeout: 300,
		//判断文件是否发生变化是通过不停询问系统指定文件有没有变化实现的，默认每秒问1000次
		poll:1000
	}
}
</code></pre>
<blockquote>
<h3 id="更好的方法-热更新wdswebpack-dev-server">更好的方法 热更新(wds)：webpack-dev-server</h3>
</blockquote>
<ul>
<li>方法1.</li>
</ul>
<br/>
<p>wds 通常与 HotModuleReplacementPlugin插件一起使用，wds的一个比较大的优势是，它没有磁盘的io,输出完之后放到内存中，而不是输出为文件，所以构建速度会有一个较大的优势。</p>
<br/>
<p>如果报错为 ： <code>'webpack-dev-server' 不是内部或外部命令，也不是可运行的程序 或批处理文件。</code>请先安装依赖：<code>yarn add webpack-dev-server -D</code></p>
<br/>
<ul>
<li>方法2.</li>
</ul>
<br/>
<p>WDM 将 webpack 输出的文件传输给服务器,使用于灵活的定制场景。</p>
<br/>
<pre><code>const express = require('express');
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-dev-middleware');

const app = express();
const config = require('./webpack.config.js');
const compiler = webpack(config);

app.use(webpackDevMiddleware(compiler,{
	publicPath: config.output.publicPath
}));

app.listen(3000,function(){
	console.log('Example app listening on post 3000\n')
})
</code></pre>
<p>在这种情况下，对webpack的配置控制会更加灵活</p>
<br/>
<blockquote>
<h3 id="webpack-热更新原理">webpack 热更新原理</h3>
</blockquote>
<ul>
<li>Webpack Compile: 将JS编译成Bundle</li>
<li>HMR Server： 将热更新的文件输出给HMR Runtime</li>
<li>Bundle server: 提供文件在浏览器的访问</li>
<li>HMR Runtime: 会被注入到浏览器，更新文件的变化</li>
<li>bundle.js 构建输出的文件</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6-你真的懂symbol吗？]]></title>
        <id>https://heihei12305.github.io/post/es6-ni-zhen-de-dong-symbol-ma</id>
        <link href="https://heihei12305.github.io/post/es6-ni-zhen-de-dong-symbol-ma">
        </link>
        <updated>2019-11-16T01:44:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>所见即所得，所见即所碍</p>
</blockquote>
<br/>
<blockquote>
<h3 id="从一个问题引入你知道现在js中有几种基本数据类型吗分别是什么呢">从一个问题引入，你知道现在js中有几种基本数据类型吗？分别是什么呢？</h3>
</blockquote>
<p>作为一道经典面试题，相信各位肯定脱口就来：字符串型，数字型，布尔型，null,undefined,es6新引入的symbol，还处于ECMAScript 标准化过程中的 第三阶段 的bigInt<br/></p>
<p>那么symbol到底是什么呢？<br/></p>
<p>接下来，我们会开始进入symbol的世界。</p>
<br/>
<p>大概目录：</p>
<ul>
<li>symbol基础</li>
<li>well-konw symbol 暴露内部操作</li>
<li>元编程</li>
</ul>
<p>内容主要来自</p>
<br/>
<ul>
<li>深入理解es6</li>
<li>你不知道的javaScript下</li>
<li><a href="https://juejin.im/post/5a0e65c1f265da430702d6b9">[译]ES6 中的元编程：第一部分 —— Symbol，了不起的 Symbol</a></li>
</ul>
<h2 id="symbol基础">symbol基础</h2>
<br/>
<h3 id="symbol-是完全唯一的">symbol 是完全唯一的</h3>
<p>在默认情况下，每一个新创建的Symbol都有一个完全唯一的值。如果你新创建了一个Symbol，在JS引擎内部，就会创建一个全新的值。</p>
<br/>
<p>Symbol函数接受一个可选的参数，其可以让你添加一段文本描述即将创建的Symbol，这段描述不可用于属性访问，但是建议你在每一次创建 Symbol 时都能加这样一段描述，以便于阅读代码和调试Symbol程序。</p>
<pre><code>let firstName = Symbol(&quot;first name&quot;);
let person = { };

person[firstName] = 'Nicholas';

console.log(&quot;first name&quot; in person);  //false
console.log(person[firstName]); //'Nicholas'
console.log(firstName); //&quot;Symbol(firstName)&quot;
</code></pre>
<p>Symbol 的描述被存储在内部的[[Description]]属性中，只有当调用Symbol的toString()方法时才可以读取这个属性。在执行 <code>console.log()</code>时，隐式调用了 firstName 的 toString() 方法，所以它的描述会被打印到日志中，但不能直接在代码里访问[[Description]]</p>
<br/>
<h3 id="symbol-判断">symbol 判断</h3>
<p>因为symbol是基本数据类型，所以判断symbol首选也最准确的检测方式是 typeof</p>
<pre><code>console.log(typeof firstName );//'symbol'
</code></pre>
<h3 id="symbol共享结构">symbol共享结构</h3>
<br/>
<p>有时候我们可能希望在不同的代码中共享同一个Symbol，例如，在你的应用中有两种不同的对象类型，但是你希望它们使用同一个Symbol 属性来表示一个独特的标识符。一般而言，在很大的代码库中或跨文件追踪 Symbol 非常困难而且容易出错，出于这些原因，ECMAScript 6 提出了一个可以随时访问的全局 Symbol 注册表。</p>
<br/>
<p>如果想创建一个可共享的Symbole,要使用<code>Symbol.for()方法</code>。它只接受一个参数，也就是即将创建的 Symbol 的字符串标识符，这个参数同样也被用于Symbol的描述。</p>
<br/>
<pre><code>let uid = Symbol.for(&quot;uid&quot;);
let object = {};

object[uid] = &quot;123456&quot;;

console.log(object[uid]); //'123456'
console.log(uid)
</code></pre>
<p>Symbol.for()方法首先在全局 Symbol 注册表中搜索键为&quot;uid&quot;的Symbol是否存在，如果存在，直接返回已有的 Symbol ;否则，创建一个新的Symbol,并使用这个键在Symbol全局注册表中注册，随即返回新创建的Symbol。</p>
<br/>
<p>后续再传入同样的键调用 Symbol.for() 会返回相同的Symbol</p>
<pre><code>let uid = Symbol.for(&quot;uid&quot;);
let object = {};
object[uid] = &quot;123456&quot;;

let uid2 = Symbol.for('uid');

console.log(uid === uid2); // true
</code></pre>
<p>还有一个与 Symbol 共享有关的特性：可以使用 Symbol.keyFor()方法在Symbol全局注册表中检索与Symbol有关的键。</p>
<pre><code>let uid = Symbol.for(&quot;uid&quot;);
let object = {};

object[uid] = &quot;123456&quot;;
let uid2 = Symbol.for('uid');

console.log(Symbol.keyFor(uid));//&quot;uid&quot;
console.log(Symbol.keyFor(uid2));//&quot;uid&quot;
console.log(Symbol.keyFor(uid3));//&quot;undefined&quot;
</code></pre>
<br/>
<p>symbol全局注册表是一个类似全局作用域的共享环境，也就是说你不能假设目前环境中存在哪些键。当使用第三方组件时，尽量使用Symbol键的命名空间以减少命名冲突，也即加上前缀。额外注意的一点是：这个注册中心是跨域的，意味着 iframe 或者sevice worker 中的 Symbol 会与当前 frame Symbol 相等。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DOMAPI完全整理]]></title>
        <id>https://heihei12305.github.io/post/domapi-wan-quan-zheng-li</id>
        <link href="https://heihei12305.github.io/post/domapi-wan-quan-zheng-li">
        </link>
        <updated>2019-11-08T05:58:31.000Z</updated>
        <content type="html"><![CDATA[<p>asda，待整理</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HIndley-Milner 类型签名]]></title>
        <id>https://heihei12305.github.io/post/hindley-milner-lei-xing-qian-ming</id>
        <link href="https://heihei12305.github.io/post/hindley-milner-lei-xing-qian-ming">
        </link>
        <updated>2019-11-07T09:05:42.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<h3 id="单纯手打方便学习回顾原文请看">单纯手打，方便学习回顾，<a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch7.html#%E5%88%9D%E8%AF%86%E7%B1%BB%E5%9E%8B">原文请看</a></h3>
<h3 id="类型签名type-signatures">类型签名(type signatures)</h3>
</blockquote>
<p>类型(type)是让所有不同背景的人都能高效沟通的元语言。很大程度上，类型签名是以&quot;HIndley-Milner&quot;系统写就的。<br/><br>
类型签名在写纯函数时所起的作用非常大。这些签名轻述着函数最不可告人的秘密。短短一行，就能暴露函数的行为和目的。类型签名还衍生出了&quot;自由定理(free theorems)&quot;的概念。因为类型是可以推断的，所以明确的类型签名并不是必要的；不过你完全可以写精确度很高的类型签名，也可以让它们保持通用，抽象。类型签名不但可以用于编译时检测(compile time checks)，还是最好的文档。所以类型签名在函数式编程中扮演着非常重要的角色--重要程度远远超过你的想象。<br/></p>
<blockquote>
<h3 id="hindley-milner类型签名">Hindley-Milner类型签名</h3>
</blockquote>
<pre><code>// capitalize :: String -&gt; String
var capitalize = function(s){
	return toUpperCase(head(s)) + toLowerCase(tail(s));
}

capitalize(&quot;smurf&quot;);
// =&gt; &quot;smurf&quot;
</code></pre>
<p>这里，<code>capitalize</code> 接受一个 <code>String</code>并返回了一个 <code>String</code>。<br>
<br/><br>
在Hindley-Milner系统中，函数都写成类型<code>a-&gt;b</code>这个样子，其中<code>a</code>和<code>b</code>是任意类型的变量。因此，<code>capitalize</code>函数的类型签名可以理解成&quot;一个接受<code>String</code>返回<code>String</code>的函数&quot;。换句话说，它接受一个<code>String</code>类型作为输入，并返回一个<code>String</code>类型的输出。<br/></p>
<pre><code>
// match :: Regex -&gt; string -&gt; [String]
var match = curry(function(reg,s){
	return s.match(reg);
});

</code></pre>
<p>不过在还不完全了解细节的条件下，你尽可以把最后一个类型视作返回值。那么<code>match</code>函数就可以这么理解： 它接受一个<code>Regex</code>和一个<code>String</code>，返回一个<code>[String]</code>。</p>
<br/>
<p>对于上面的match函数我们完全可以把它的类型签名这样分组：</p>
<br/>
<pre><code>//match :: Regex -&gt; (String-&gt; [String])
var match = curry(function(reg,s){
	return s.match(reg);
});
</code></pre>
<p>把最后两个类型包在括号里就能反映更多的信息了。现在我们可以看出<code>match</code>这个函数接受一个<code>Regex</code>作为参数，返回一个从<code>String</code>到<code>[String]</code>的函数。因为 curry 造成的结果就是这样：给<code>match</code>一个<code>Regex</code>，得到一个新函数，能够处理其<code>String</code>参数。</p>
<br/>
<p>最后：</p>
<pre><code>// id :: a -&gt; a
var id  = function(x){ return x; }

//map :: (a -&gt; b) -&gt; [a] -&gt; [b]
var map = curry(function(f,xs)){
	return xs.map(f);
});
</code></pre>
<p>这里的<code>id</code>函数接受任意类型的<code>a</code>并返回一个类型的数据。和普通代码一样，我们也可以在类型签名中使用变量。把变量命名为<code>a</code>和<code>b</code>只是一种约定俗成的习惯，你可以使用任何你喜欢的名称。对于相同的变量名，其类型也一定相同。这是非常重要的原则，所以我们必须重申：<code>a -&gt; b</code>可以是从任意类型中<code>a</code>到任意类型<code>b</code>，但是<code>a -&gt; a</code>必须是同一类型。例如，<code>id</code><br>
可以是<code>String -&gt; String</code>，也可以是<code>Number -&gt; Number</code>，但不能是<code>String -&gt; Bool</code>。</p>
<br/>
<p>相似地，<code>map</code>也使用了变量，只不过这里的<code>b</code>可能与<code>a</code>类型相同，也可能不相同。我们可以这么理解：<code>map</code>接受两个参数，第一个是从任意类型<code>a</code>到任意类型<code>b</code>的函数；第二个是一个数组，元素是任意类型的<code>a</code>;<code>map</code>最后返回的是一个类型<code>b</code>的数组。</p>
<br/>
<pre><code>// reduce :: (b -&gt;  a -&gt; b) -&gt; b -&gt; [a] -&gt; b
var reduce = curry(function(f,x,xs){
	return xs.reduce(f, x);
});
</code></pre>
<p>&quot;here goes nothing&quot; , 可以看出它的第一个参数是一个函数，这个函数接受一个<code>b</code>和一个<code>a</code>并返回一个<code>b</code>。那么这些<code>a</code>和<code>b</code>是从哪来的呢？很简单，签名中的第二个和第三个参数就是<code>b</code>和元素为<code>a</code>的数组，所以唯一合理的假设就是这里的<code>b</code>和每一个<code>a</code>都将传给前面说的函数作为参数。我们还可以看到，<code>reduce</code>函数最后返回的结果是一个<code>b</code>，也就是说，<code>reduce</code>的第一个参数函数的输出就是<code>reduce</code>函数的输出。</p>
 <br/>
<blockquote>
<h3 id="缩小可能性范围">缩小可能性范围</h3>
</blockquote>
<p>一旦引入一个类型变量，就会出现一个奇怪的特性叫做：parametricity。这个特性表明，函数将会以一个统一的行为作用于所有的类型。</p>
<pre><code>// head :: [a] -&gt; a
</code></pre>
<p>注意看 <code>head</code>，可以看到它接受<code>[a]</code>返回<code>a</code>。我们除了知道参数是个数组，其他一概不知；所以函数的功能就只限于操作这个数组上。在它对<code>a</code>一无所知的情况下，它可能对<code>a</code>进行什么操作呢?换句话说，<code>a</code>告诉我们它不是一个特定的类型，这意味着它们可以是任意类型；那么我们的函数对每一个可能的类型的操作都必须保持统一。这就是parametricity的含义。要让我们来猜测<code>head</code>的实现的话，唯一合理的推断就是它返回数组的第一个，或者最后一个，或者某个随机的元素；当然，<code>head</code>这个命名应该能给我们一些线索。</p>
<blockquote>
<h3 id="自由定理">自由定理</h3>
</blockquote>
<p>类型签名除了能够帮助我们判断函数可能的实现，还能够给我们带来自由定理（free theorems）。</p>
<br/>
<pre><code>// head :: [a] -&gt; a
compose(f,head) == compose(head, map(f));

//filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
compose(map(f),filter(compose(p,f))) == compose(filter(p),map(f));
</code></pre>
<p>第一个例子中，等式左边说的是，先获取数组的头部，然后对它调用函数f;等式右边说的是，先对数组中的每一个元素调用f，然后再取其返回结果的头部，这两个表达式是相等的，但是前者要快得多。</p>
<br/>
<p>你可能会想，这不是常识么，但计算机是没有常识的。实际上，计算机必须要有一种形式化方法来自动进行类似的代码优化。数学提供了这种方法，能够形式化直观的感觉，这无疑对死板的计算机逻辑非常有用。</p>
<br/>
<blockquote>
<h3 id="类型约束">类型约束</h3>
</blockquote>
<p>签名也可以把类型约束成一个特定的接口</p>
<pre><code>// sort :: ord a =&gt; [a] -&gt; [a]
</code></pre>
<p>胖箭头左边表明的是这么一个事实：<code>a</code>一定是个<code>ord</code>对象。也就是说，<code>a</code>必须要实现<code>ord</code>接口。<code>ord</code>到底是什么？它从哪里来？在一门强类型语言中，它可能就是一个自定义的接口，能够让不同的值排序。通过这种方式，我们不仅能够获取关于<code>a</code>的更多信息，了解<code>sort</code>函数具体要干什么，而且还能限制函数的作用范围。我们把这种接口声明叫做类型约束(type constraints)</p>
<pre><code>// assertEqual :: (Eq a , Show a) =&gt; a -&gt; a -&gt; Assertion
</code></pre>
<p>这个例子中有两个约束： <code>Eq</code> 和 <code>Show</code> 。它们保证了我们可以检查不同的<code>a</code>是否相等， 并在有不相等的情况下打印出其中的差异。</p>
<blockquote>
<h3 id="总结">总结</h3>
</blockquote>
<p>Hindley-Milner 类型签名在函数式编程中无处不在，它们简单易读，写起来也不复杂。但仅仅凭签名就能理解整个程序还是有一定难度的，要想精通这个技能就更要花点时间了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串转换成二进制流]]></title>
        <id>https://heihei12305.github.io/post/zi-fu-chuan-zhuan-huan-cheng-er-jin-zhi-liu</id>
        <link href="https://heihei12305.github.io/post/zi-fu-chuan-zhuan-huan-cheng-er-jin-zhi-liu">
        </link>
        <updated>2019-11-04T08:50:55.000Z</updated>
        <content type="html"><![CDATA[<pre><code>this.char2buf = function(str) {
      var out = new ArrayBuffer(str.length*2);
      var u16a= new Uint16Array(out);
      var strs = str.split(&quot;&quot;);
      for(var i =0 ; i&lt;strs.length;i++){
          u16a[i]=strs[i].charCodeAt();
      }
      return out;
  }
</code></pre>
<p>示例：<br>
<img src="https://heihei12305.github.io/post-images/1573027364453.PNG" alt=""></p>
<p>也即输出为 ArrayBuffer 类型。</p>
<blockquote>
<p>MDN 中 <code>ArrayBuffer</code> 定义：<code>ArrayBuffer</code>对象用来表示通用的，固定长度的原始二进制数据缓冲区。<code>ArrayBuffer</code>不能直接操作，而是要通过类数组对象或DataView对象来操作。它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[判断设备及浏览器类型]]></title>
        <id>https://heihei12305.github.io/post/pan-duan-she-bei-ji-liu-lan-qi-lei-xing</id>
        <link href="https://heihei12305.github.io/post/pan-duan-she-bei-ji-liu-lan-qi-lei-xing">
        </link>
        <updated>2019-11-04T08:46:47.000Z</updated>
        <content type="html"><![CDATA[<pre><code>getDevice = function() {
      var device = {};
      var ua = navigator.userAgent;
      var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
      var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
      var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
      var iphone = !ipad &amp;&amp; ua.match(/(iPhone\sOS)\s([\d_]+)/);
      var mobileInfo = ua.match(/Android\s[\S\s]+Build\//);
      device.ios = device.android = device.iphone = device.ipad = device.androidChrome = false;
      device.isWeixin = /MicroMessenger/i.test(ua);
      device.os = &quot;web&quot;;
      device.deviceName = &quot;PC&quot;;
      // Android
      if (android) {
        device.os = 'android';
        device.osVersion = android[2];
        device.android = true;
        device.androidChrome = ua.toLowerCase().indexOf('chrome') &gt;= 0;
      }
      if (ipad || iphone || ipod) {
        device.os = 'ios';
        device.ios = true;
      }
      // iOS
      if (iphone &amp;&amp; !ipod) {
        device.osVersion = iphone[2].replace(/_/g, '.');
        device.iphone = true;
      }
      if (ipad) {
        device.osVersion = ipad[2].replace(/_/g, '.');
        device.ipad = true;
      }
      if (ipod) {
        device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
        device.iphone = true;
      }
      // iOS 8+ changed UA
      if (device.ios &amp;&amp; device.osVersion &amp;&amp; ua.indexOf('Version/') &gt;= 0) {
        if (device.osVersion.split('.')[0] === '10') {
          device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
        }
      }

      // 如果是ios, deviceName 就设置为iphone，根据分辨率区别型号
      if (device.iphone) {
        device.deviceName = &quot;iphone&quot;;
        var screenWidth = window.screen.width;
        var screenHeight = window.screen.height;
        if (screenWidth === 320 &amp;&amp; screenHeight === 480) {
          device.deviceName = &quot;iphone 4&quot;;
        } else if (screenWidth === 320 &amp;&amp; screenHeight === 568) {
          device.deviceName = &quot;iphone 5/SE&quot;;
        } else if (screenWidth === 375 &amp;&amp; screenHeight === 667) {
          device.deviceName = &quot;iphone 6/7/8&quot;;
        } else if (screenWidth === 414 &amp;&amp; screenHeight === 736) {
          device.deviceName = &quot;iphone 6/7/8 Plus&quot;;
        } else if (screenWidth === 375 &amp;&amp; screenHeight === 812) {
          device.deviceName = &quot;iphone X/S/Max&quot;;
        }
      } else if (device.ipad) {
        device.deviceName = &quot;ipad&quot;;
      } else if (mobileInfo) {
        var info = mobileInfo[0];
        var deviceName = info.split(';')[1].replace(/Build\//g, &quot;&quot;);
        device.deviceName = deviceName.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);
      }
      // 浏览器模式, 获取浏览器信息
      // TODO 需要补充更多的浏览器类型进来
      if (ua.indexOf(&quot;Mobile&quot;) == -1) {
        var agent = navigator.userAgent.toLowerCase() ;
        var regStr_ie = /msie [\d.]+;/gi ;
        var regStr_ff = /firefox\/[\d.]+/gi
        var regStr_chrome = /chrome\/[\d.]+/gi ;
        var regStr_saf = /safari\/[\d.]+/gi ;

        device.browserName = '未知';
        //IE
        if(agent.indexOf(&quot;msie&quot;) &gt; 0) {
          var browserInfo = agent.match(regStr_ie)[0];
          device.browserName = browserInfo.split('/')[0];
          device.browserVersion = browserInfo.split('/')[1];
        }
        //firefox
        if(agent.indexOf(&quot;firefox&quot;) &gt; 0) {
          var browserInfo = agent.match(regStr_ff)[0];
          device.browserName = browserInfo.split('/')[0];
          device.browserVersion = browserInfo.split('/')[1];
        }
        //Safari
        if(agent.indexOf(&quot;safari&quot;) &gt; 0 &amp;&amp; agent.indexOf(&quot;chrome&quot;) &lt; 0) {
          var browserInfo = agent.match(regStr_saf)[0];
          device.browserName = browserInfo.split('/')[0];
          device.browserVersion = browserInfo.split('/')[1];
        }
        //Chrome
        if(agent.indexOf(&quot;chrome&quot;) &gt; 0) {
          var browserInfo = agent.match(regStr_chrome)[0];
          device.browserName = browserInfo.split('/')[0];
          device.browserVersion = browserInfo.split('/')[1];
        }
      }
      // Webview
      device.webView = (iphone || ipad || ipod) &amp;&amp; ua.match(/.*AppleWebKit(?!.*Safari)/i);

      // Export object
      return device;
    }
	```</code></pre>
]]></content>
    </entry>
</feed>