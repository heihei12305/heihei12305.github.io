<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://heihei12305.github.io</id>
    <title>heihei12305</title>
    <updated>2019-12-24T11:28:47.762Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://heihei12305.github.io"/>
    <link rel="self" href="https://heihei12305.github.io/atom.xml"/>
    <subtitle>所见即所得，所见即所碍</subtitle>
    <logo>https://heihei12305.github.io/images/avatar.png</logo>
    <icon>https://heihei12305.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, heihei12305</rights>
    <entry>
        <title type="html"><![CDATA[webpack-进阶用法🚔]]></title>
        <id>https://heihei12305.github.io/post/webpack-jin-jie-yong-fa</id>
        <link href="https://heihei12305.github.io/post/webpack-jin-jie-yong-fa">
        </link>
        <updated>2019-12-23T15:30:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="自动清理构建目录产物">🏍 自动清理构建目录产物</h2>
<br/>
<h3 id="通过-npm-scripts清理构建目录">🚲 通过 <code>npm scripts</code>清理构建目录</h3>
<pre><code>rm -rf ./dist &amp;&amp; webpack
rimraf ./dist &amp;&amp; webpack
</code></pre>
<p>不过这个 <code>rm -rf</code> 看起来有点😨，不很优雅。</p>
<br/>
<h3 id="通过-clean-webpack-plugin-插件">🛵 通过 <code>clean-webpack-plugin</code> 插件</h3>
<br/>
<p><b>默认会删除output指定的输出目录</b></p>
<br/>
<pre><code>module.exports = {
    entry:{
        app:'./src/app.js',
        search:'./src/search.js'
    },
    output:{
        filename:'[name][chunkhash:8].js',
        path:__dirname+'/dist'
    },
    plugins:[
        new CleanWebpackPlugin()
    ]
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[webpack-js,html,css压缩🗜️]]></title>
        <id>https://heihei12305.github.io/post/webpack-jshtmlcss-ya-suo</id>
        <link href="https://heihei12305.github.io/post/webpack-jshtmlcss-ya-suo">
        </link>
        <updated>2019-12-23T14:42:33.000Z</updated>
        <content type="html"><![CDATA[<p>又又又开始继续学习webpack啦！🏷</p>
<br/>
<p>本文记录有关webpack压缩🗜️相关的东西。</p>
<br/>
<blockquote>
<p>所见即所得，所见即所碍。</p>
</blockquote>
<p>start</p>
<br/>
<h3 id="javascript-压缩">JavaScript 压缩</h3>
<br/>
<p>内置了<code>uglifyjs-webpack-plugin</code>,所以默认打包出来的js文件已经被压缩。但是我们也可以自行安装该插件去开启并行压缩等。</p>
<br/>
<h3 id="css文件压缩">css文件压缩</h3>
<br/>
<p>使用 <code>optimize-css-assets-webpack-plugin</code>,同时使用<code>cssnano</code></p>
<pre><code>module.exports = {
    entry:{
        app:'./src/app.js',
        search:'./src/search.js'
    },
    output:{
        filename:'[name][chunkhash:8].js',
        path:__dirname+'/dist'
    }，
    plugin:[
        new OptimizeCSSAssentsPlugin({
            assetNameRegExp:/\.css$/g,
            cssProcessor:require('cssnano')
        })
    ]
}
</code></pre>
<p>匹配到所有的css文件，再通过<code>cssnano</code>对css进行压缩。</p>
<br/>
<h3 id="html文件压缩">html文件压缩</h3>
<br/>
<p>修改 <code>html-webpack-plugin</code>,设置压缩参数。</p>
<br/>
<pre><code>module.exports = {
    entry:{
        app:'./src/app.js',
        search:'./src/search.js'
    },
    output:{
        filename:'[name][chunkhash:8].js',
        path:__dirname+'/dist'
    },
    plugins:[
        new HtmlWebpackPlugin({
            template:path.join(__dirname,'src/search.html'),
            filename:'search.html',
            chunks:['search'],
            inject:true,
            minify:{
                html5:true,
                collapseWhitespace:true,
                preserveLineBreaks:false,
                minifyCSS:true,
                minifyJS:true,
                removeComments:false
            }
        })
    ]
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react-jsx 备忘]]></title>
        <id>https://heihei12305.github.io/post/react-jsx-bei-wang</id>
        <link href="https://heihei12305.github.io/post/react-jsx-bei-wang">
        </link>
        <updated>2019-12-19T07:29:19.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<h2 id="本文仅作备忘详情请查看官方文档">本文仅作备忘，详情请查看<a href="https://zh-hans.reactjs.org/docs/jsx-in-depth.html">官方文档</a></h2>
</blockquote>
<h3 id="用户定义的组件必须以大写字母开头">用户定义的组件必须以大写字母开头</h3>
<p>以小写字母开头的元素代表一个HTML内置组件，比如<code>&lt;div&gt;</code>或者<code>&lt;span&gt;</code>会生成对应的字符串<code>'div'</code>或者<code>'span'</code>传递给<code>React.createElement</code>（作为参数）。大写字母开头的元素则对应着在JavaScript引入或自定义的组件，如<code>&lt;Foo /&gt;</code>会编译为<code>React.createElement(Foo)</code>。</p>
<br/>
<p>我们建议使用大写字母开头命名自定义组件。如果你确实需要一个以小写字母开头的组件，则在JSX中使用它之前，必须将它赋值给一个小写字母开头的变量。</p>
<br/>
<p>例如，以下的代码将无法按预期进行：</p>
<pre><code>import React from 'react';

//错误！组件应该以大写字母开头：
function hello(props) {
	//正确！这种&lt;div&gt;的使用是合法的，因为div是一个有效的HTML标签
	return &lt;div&gt;Hello {props.toWhat}&lt;/div&gt;
}

function HelloWorld() {
	//错误！React会认为&lt;hello /&gt;是一个HTML标签，因为它没有以大写字母开头；
	return &lt;hello toWhat=&quot;World&quot; /&gt;
}
</code></pre>
<h3 id="属性展开">属性展开</h3>
<br/>
<p>如果你已经有了一个props对象，你可以使用展开运算符<code>...</code>来在JSX中传递整个props对象。以下两个组件是等价的：</p>
<pre><code>function App1() {
	return &lt;Greeting firstName=&quot;Ben&quot; lastName=&quot;Hector&quot;&gt;;
}
function App2() {
	const props = {firstName: 'Ben',lastName: 'Hector'};
	return &lt;Greeting {...props} /&gt;
}
</code></pre>
<p>你还可以选择只保留当前组件需要接收的props，并使用展开运算符将其他props传递下去。</p>
<pre><code>const Button = props =&gt; {
	const { kind,...other } = props;
	const className = kind === 'primary' ? 'primaryButton' : 'SecondaryButton';
	return &lt;button className={className} {...other} /&gt;;
};

const App = () =&gt; {
	return (
		&lt;div&gt;
			&lt;Button kind=&quot;primary&quot; onClick={() =&gt; console.log(&quot;clicked!&quot;)}&gt;
				Hello World!
			&lt;/Button&gt;
		&lt;/div&gt;
	);
};
</code></pre>
<h3 id="布尔类型null以及undefined将被忽略">布尔类型，Null以及Undefined将被忽略</h3>
<br/>
<p><code>false</code>,<code>null</code>,<code>undefined</code>.<code>true</code>是合法的子元素。但它们并不会被渲染。以下的JSX表达式渲染结果相同：</p>
<pre><code>&lt;div /&gt;

&lt;div&gt;&lt;/div&gt;

&lt;div&gt;{false}&lt;/div&gt;

&lt;div&gt;{null}&lt;/div&gt;

&lt;div&gt;{undefined}&lt;/div&gt;

&lt;div&gt;{true}&lt;/div&gt;
</code></pre>
<p>这有助于依据特定条件来渲染其他的React元素。例如，在以下JSX中，仅当<code>showHeader</code>为<code>true</code>时，才会渲染<code>&lt;Header /&gt;</code>组件：</p>
<pre><code>&lt;div&gt;
	{showHeader &amp;&amp; &lt;Header /&gt;}
	&lt;Content /&gt;
&lt;/div&gt;
</code></pre>
<p>值得注意的是一些&quot;falsy&quot;值，仍然会被React渲染。例如，以下代码并不会像你预期那样工作，因为当<code>props.messages</code>是空数组时，<code>0</code>仍然会被渲染：</p>
<pre><code>&lt;div&gt;
	{props.message.length &amp;&amp;
		&lt;MessageList messages={props.messages} /&gt;
	}
&lt;/div&gt;
</code></pre>
<p>要解决这个问题，确保 &amp;&amp; 之前的布尔表达式总是布尔值：</p>
<pre><code>&lt;div&gt;
	{props.message.length &gt;0  &amp;&amp;
		&lt;MessageList messages={props.messages} /&gt;
	}
&lt;/div&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[react 学习笔记]]></title>
        <id>https://heihei12305.github.io/post/react-xue-xi-bi-ji</id>
        <link href="https://heihei12305.github.io/post/react-xue-xi-bi-ji">
        </link>
        <updated>2019-12-12T06:06:47.000Z</updated>
        <content type="html"><![CDATA[<p>备忘：</p>
<ul>
<li>
<p>脚手架 npm i create-react-app</p>
</li>
<li>
<p>创建 npx create-react-app [项目名]</p>
</li>
<li>
<p>pwa serviceWorker 离线应用</p>
</li>
<li>
<p>jsx 同时解析 html 和 js ： 遇到 &lt; 按照 html，遇到 { 按照 js</p>
</li>
<li>
<p>类名为 className，不能直接写class</p>
</li>
<li>
<p>fragment 在最外面套一层，不会影响布局（直接套div报错）</p>
</li>
<li>
<p>jsx return 为 html时，外面套上括号可支持换行</p>
</li>
<li>
<p>修改列表的值的时候，先用临时变量获取，然后修改，然后重新赋值。不允许直接操作原数据！虽然不报错，但是后期性能优化会遇到巨大障碍。</p>
</li>
<li>
<p>jsx的几个坑</p>
<ul>
<li>注释：<code>{/*第一次写注释*/}</code> 也可以写 // 不过需要换行，建议写上面那个</li>
<li>在jsx中css样式使用class要用className(防止与class混淆)</li>
<li>input中输入的value默认不会被解析为html，可使用 <code>dangerouslySetlnnerHTML = { {__html: item} }</code>来解析为html</li>
<li>label辅助标签，为了不与js中的for重复，需要使用htmlFor来代替for完成对标input的id功能。</li>
</ul>
</li>
<li>
<p>vscode 中的快速生成插件 simple react</p>
<ul>
<li>imr <code>import React from 'react'</code>;</li>
<li>imrc <code>import React,{ Component } from 'react'</code>;</li>
<li>impt <code>import Protypes from 'prop-types'</code>;</li>
<li>impc <code>import React, { PureComponent } from 'react'</code></li>
<li>cc</li>
</ul>
</li>
</ul>
<pre><code>class | extends Component {
	state = { | },
	render() {
		return ( | );
	}
}

export default |;
</code></pre>
<ul>
<li>ccc</li>
</ul>
<pre><code>class | extends Component {
	constructor(props) {
		super(props);
		this.state = { | };
	}
	render() {
		return ( | );
	}
}

export default |;
</code></pre>
<ul>
<li>sfc</li>
</ul>
<pre><code>const | = props =&gt; {
	return ( | );
};

export default |;
</code></pre>
<ul>
<li>cdm</li>
</ul>
<pre><code>componentDidMount() {
	|
}
</code></pre>
<ul>
<li>cwm</li>
</ul>
<pre><code>//WARING! To be deprecated in React v17. Use new lifecycle  static getDerivedStateFeomProps instead
componentWillReceiveProps(nextProps) {
	|
}
</code></pre>
<ul>
<li>gds</li>
</ul>
<pre><code>static getDerivedStateFromProps(nextProps, preStat) {
	|
}
</code></pre>
<ul>
<li>scu</li>
</ul>
<pre><code>shouldComponentUpdate(nextProps, nextState) {
	|
}
</code></pre>
<ul>
<li>cwu</li>
</ul>
<pre><code>//WARING! To be deprecated in React v17. Use componentDidUpdate instead
componentWillUpdate(nextProps, nextState) {
	|
}
</code></pre>
<ul>
<li>cdu</li>
</ul>
<pre><code>componentDidUpdate(prevProps, prevSatte) {
	|
}
</code></pre>
<ul>
<li>cwun</li>
</ul>
<pre><code>componentWillUnmount() {
	|
}
</code></pre>
<ul>
<li>cdc</li>
</ul>
<pre><code>componentDidCatch(error, info) {
	|
}
</code></pre>
<ul>
<li>gsdu</li>
</ul>
<pre><code>getSnapshotBeforeUpdate(prevProps, prevState) {
	|
}
</code></pre>
<ul>
<li>ss</li>
</ul>
<pre><code>this.setState({ | : | });
</code></pre>
<ul>
<li>ssf</li>
</ul>
<pre><code>this.setState(prevState =&gt; {
	return { | : prevState.| }
});
</code></pre>
<ul>
<li>ren</li>
</ul>
<pre><code>render() {
	return (
		|
	);
}
</code></pre>
<ul>
<li>rprop</li>
</ul>
<pre><code>class | extends Component {
	state = { | },
	render() {
		return this.props.render({
			|: this.state.|
		})
	}
}
</code></pre>
<ul>
<li>hoc</li>
</ul>
<pre><code>function | (|) {
	return class extends Component {
		constructor(props) {
			super(props);
		}
		
		render() {
			return &lt; | { ...this.props} /&gt;
		}
	};
}
</code></pre>
<ul>
<li>proto-type 可检验传值类型</li>
<li>必须传递 可用 <code>prototype.string.isrequired</code></li>
<li>组件第一次存在于DOM中，函数是不会被执行的，如果已经存在于DOM中，函数才会被执行。</li>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql  学习记录]]></title>
        <id>https://heihei12305.github.io/post/mysql-xue-xi-ji-lu</id>
        <link href="https://heihei12305.github.io/post/mysql-xue-xi-ji-lu">
        </link>
        <updated>2019-12-06T12:05:29.000Z</updated>
        <content type="html"><![CDATA[<p>mysql 文件夹  C:\Users\24241\Downloads\mysql-8.0\mysql-8.0.18-winx64\bin<br>
root 登陆  mysql -u root -p<br>
查询用户名密码  select host,user,authentication_string from mysql.user;<br>
创建数据库 CREATE DATABASE 数据库名;<br>
显示当前数据库 show databases;<br>
使用数据库  use 数据库名；</p>
<p>创建数据表  CREATE TABLE table_name (column_name column_type);<br>
删除数据表  DROP TABLE table_name ;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[webpack-文件指纹策略及将css单独提取出来]]></title>
        <id>https://heihei12305.github.io/post/webpack-wen-jian-zhi-wen-ce-lue</id>
        <link href="https://heihei12305.github.io/post/webpack-wen-jian-zhi-wen-ce-lue">
        </link>
        <updated>2019-11-26T23:31:50.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<h3 id="一般指的是打包后输出的文件名的后缀">一般指的是打包后输出的文件名的后缀。</h3>
</blockquote>
<h3 id="文件指纹如何生成">文件指纹如何生成？</h3>
<ul>
<li>Hash: 和整个项目的构建相关，只要项目文件有修改，整个项目构建的hash值就会更改。</li>
<li>Chunhash: 和webpack 打包的chunk有关，不同的entry会生成不同的chunkhash值。</li>
<li>Contenthash: 根据文件内容来定义hash，文件内容不变，则contenthash不变。</li>
</ul>
<br/>
### JS的文件指纹设置
<br/>
<p>设置output的filename，使用 [chunkhash]</p>
<pre><code>module.exports = {
	entry:{
		app:'./src/app.js',
		search:'./src/search.js'
	},
	output:{
		filename:'[name][chunkhash:8].js',
		path:__dirname+'/dist'
	}
};
</code></pre>
<h3 id="css文件的文件指纹设置">css文件的文件指纹设置</h3>
<br/>
<p>对于css文件，我们使用 contenthash<br/><br>
设置 MiniCssExtractPlugin 的 filename</p>
<pre><code>module.exports = {
	entry:{
		app:'./src/app.js',
		search:'./src/search.js'
	},
	output:{
		new MiniCssExtractPlugin({
			filename: `[name][contenthash:8].css`
		})
	}
}
</code></pre>
<h3 id="图片的文件指纹设置">图片的文件指纹设置</h3>
<br/>
<table>
<thead>
<tr>
<th style="text-align:center">占位符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[ext]</td>
<td style="text-align:center">资源后缀名</td>
</tr>
<tr>
<td style="text-align:center">[name]</td>
<td style="text-align:center">文件名称</td>
</tr>
<tr>
<td style="text-align:center">[path]</td>
<td style="text-align:center">文件的相对路径</td>
</tr>
<tr>
<td style="text-align:center">[folder]</td>
<td style="text-align:center">文件所在的文件夹</td>
</tr>
<tr>
<td style="text-align:center">[contenthash]</td>
<td style="text-align:center">文件的内容hash，默认是md5生成</td>
</tr>
<tr>
<td style="text-align:center">[hash]</td>
<td style="text-align:center">文件内容的Hash，默认是md5生成</td>
</tr>
<tr>
<td style="text-align:center">[emoji]</td>
<td style="text-align:center">一个随机的指代文件内容的emoj</td>
</tr>
</tbody>
</table>
<br/>
<pre><code>const path = require('path');

module.exports = {
	entry: './src/index.js',
	output:{
		filename: 'bundle.js',
		path:path.resolve(__dirname,'dist')
	},
	module:{
		rules:[
			{
				test:/\.(png|svg|jpg|gif)$/,
				use:[{
					loader:'file-loader',
					options:{
						name:'img/[name][hash:8].[ext]'
					}
				}]
			}
		]
	}
}

</code></pre>
<br/>
<p>为了将css独立出来</p>
<br/>
<p>安装 <code>mini-css-extract-plugin</code> 插件</p>
<br/>
<p>与<code>style-loader</code>插件互斥，因为 <code>mini-css-extract-plugin</code>为了将css样式提取出来，而<code>style-loader</code>则为了将样式写入header中。</p>
<br/>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[webpack文件监听及热更新原理]]></title>
        <id>https://heihei12305.github.io/post/webpack-wen-jian-jian-ting-ji-re-geng-xin-yuan-li</id>
        <link href="https://heihei12305.github.io/post/webpack-wen-jian-jian-ting-ji-re-geng-xin-yuan-li">
        </link>
        <updated>2019-11-23T11:40:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<h3 id="文件监听">文件监听</h3>
</blockquote>
<p>文件监听是在发现源码发生变化时，自动重新构建出新的输出文件。</p>
<br/>
<p>在webpack中开启监听模式，有两种方式：</p>
<ul>
<li>启动webpack命令时，带上 --watch 参数</li>
<li>在配置 webpack.config.js中设置 watch: true</li>
</ul>
<h3 id="唯一缺陷每次需要手动刷新浏览器">唯一缺陷：每次需要手动刷新浏览器</h3>
 <br/>
<blockquote>
<h3 id="文件监听原理分析">文件监听原理分析</h3>
</blockquote>
<p>轮询判断文件的最后编辑时间是否变化</p>
<br/>
<p>某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 aggregateTimeout</p>
<pre><code>module.export = {
	//默认为flase，也就是不开启
	watch: true,
	//只有开启监听模式，watchOptions才有意义
	watchOptions: {
		//默认为空，不监听的文件或者文件夹，支持正则匹配
		ignored: /node_modules/,
		//监听到变化发生后会等300ms再去执行，默认300ms
		aggregateTimeout: 300,
		//判断文件是否发生变化是通过不停询问系统指定文件有没有变化实现的，默认每秒问1000次
		poll:1000
	}
}
</code></pre>
<blockquote>
<h3 id="更好的方法-热更新wdswebpack-dev-server">更好的方法 热更新(wds)：webpack-dev-server</h3>
</blockquote>
<ul>
<li>方法1.</li>
</ul>
<br/>
<p>wds 通常与 HotModuleReplacementPlugin插件一起使用，wds的一个比较大的优势是，它没有磁盘的io,输出完之后放到内存中，而不是输出为文件，所以构建速度会有一个较大的优势。</p>
<br/>
<p>如果报错为 ： <code>'webpack-dev-server' 不是内部或外部命令，也不是可运行的程序 或批处理文件。</code>请先安装依赖：<code>yarn add webpack-dev-server -D</code></p>
<br/>
<ul>
<li>方法2.</li>
</ul>
<br/>
<p>WDM 将 webpack 输出的文件传输给服务器,使用于灵活的定制场景。</p>
<br/>
<pre><code>const express = require('express');
const webpack = require('webpack');
const webpackDevMiddleware = require('webpack-dev-middleware');

const app = express();
const config = require('./webpack.config.js');
const compiler = webpack(config);

app.use(webpackDevMiddleware(compiler,{
	publicPath: config.output.publicPath
}));

app.listen(3000,function(){
	console.log('Example app listening on post 3000\n')
})
</code></pre>
<p>在这种情况下，对webpack的配置控制会更加灵活</p>
<br/>
<blockquote>
<h3 id="webpack-热更新原理">webpack 热更新原理</h3>
</blockquote>
<ul>
<li>Webpack Compile: 将JS编译成Bundle</li>
<li>HMR Server： 将热更新的文件输出给HMR Runtime</li>
<li>Bundle server: 提供文件在浏览器的访问</li>
<li>HMR Runtime: 会被注入到浏览器，更新文件的变化</li>
<li>bundle.js 构建输出的文件</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6-你真的懂symbol吗❓🦝(上)]]></title>
        <id>https://heihei12305.github.io/post/es6-ni-zhen-de-dong-symbol-ma</id>
        <link href="https://heihei12305.github.io/post/es6-ni-zhen-de-dong-symbol-ma">
        </link>
        <updated>2019-11-16T01:44:13.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>所见即所得，所见即所碍</p>
</blockquote>
<br/>
<blockquote>
<h3 id="从一个问题引入你知道现在js中有几种基本数据类型吗分别是什么呢">从一个问题引入，你知道现在js中有几种基本数据类型吗？分别是什么呢？</h3>
</blockquote>
<p>作为一道经典面试题，相信各位肯定脱口就来：字符串型，数字型，布尔型，null,undefined,es6新引入的symbol，还处于ECMAScript 标准化过程中的 第三阶段 的bigInt<br/></p>
<p>那么symbol到底是什么呢？<br/></p>
<p>接下来，我们会开始进入symbol的世界。</p>
<br/>
<p>大概目录：</p>
<ul>
<li>symbol基础</li>
<li>well-konw symbol 暴露内部操作</li>
<li>元编程</li>
</ul>
<p>内容主要来自</p>
<br/>
<ul>
<li>深入理解es6</li>
<li>你不知道的javaScript下</li>
<li><a href="https://juejin.im/post/5a0e65c1f265da430702d6b9">[译]ES6 中的元编程：第一部分 —— Symbol，了不起的 Symbol</a></li>
</ul>
<h2 id="symbol基础">symbol基础</h2>
<br/>
<h3 id="symbol-是完全唯一的">symbol 是完全唯一的</h3>
<p>在默认情况下，每一个新创建的Symbol都有一个完全唯一的值。如果你新创建了一个Symbol，在JS引擎内部，就会创建一个全新的值。</p>
<br/>
<p>Symbol函数接受一个可选的参数，其可以让你添加一段文本描述即将创建的Symbol，这段描述不可用于属性访问，但是建议你在每一次创建 Symbol 时都能加这样一段描述，以便于阅读代码和调试Symbol程序。</p>
<pre><code>let firstName = Symbol(&quot;first name&quot;);
let person = { };

person[firstName] = 'Nicholas';

console.log(&quot;first name&quot; in person);  //false
console.log(person[firstName]); //'Nicholas'
console.log(firstName); //&quot;Symbol(firstName)&quot;
</code></pre>
<p>Symbol 的描述被存储在内部的[[Description]]属性中，只有当调用Symbol的toString()方法时才可以读取这个属性。在执行 <code>console.log()</code>时，隐式调用了 firstName 的 toString() 方法，所以它的描述会被打印到日志中，但不能直接在代码里访问[[Description]]</p>
<br/>
<h3 id="symbol-判断">symbol 判断</h3>
<p>因为symbol是基本数据类型，所以判断symbol首选也最准确的检测方式是 typeof</p>
<pre><code>console.log(typeof firstName );//'symbol'
</code></pre>
<h3 id="symbol共享结构">symbol共享结构</h3>
<br/>
<p>有时候我们可能希望在不同的代码中共享同一个Symbol，例如，在你的应用中有两种不同的对象类型，但是你希望它们使用同一个Symbol 属性来表示一个独特的标识符。一般而言，在很大的代码库中或跨文件追踪 Symbol 非常困难而且容易出错，出于这些原因，ECMAScript 6 提出了一个可以随时访问的全局 Symbol 注册表。</p>
<br/>
<p>如果想创建一个可共享的Symbole,要使用<code>Symbol.for()方法</code>。它只接受一个参数，也就是即将创建的 Symbol 的字符串标识符，这个参数同样也被用于Symbol的描述。</p>
<br/>
<pre><code>let uid = Symbol.for(&quot;uid&quot;);
let object = {};

object[uid] = &quot;123456&quot;;

console.log(object[uid]); //'123456'
console.log(uid)
</code></pre>
<p>Symbol.for()方法首先在全局 Symbol 注册表中搜索键为&quot;uid&quot;的Symbol是否存在，如果存在，直接返回已有的 Symbol ;否则，创建一个新的Symbol,并使用这个键在Symbol全局注册表中注册，随即返回新创建的Symbol。</p>
<br/>
<p>后续再传入同样的键调用 Symbol.for() 会返回相同的Symbol</p>
<pre><code>let uid = Symbol.for(&quot;uid&quot;);
let object = {};
object[uid] = &quot;123456&quot;;

let uid2 = Symbol.for('uid');

console.log(uid === uid2); // true
</code></pre>
<p>还有一个与 Symbol 共享有关的特性：可以使用 Symbol.keyFor()方法在Symbol全局注册表中检索与Symbol有关的键。</p>
<pre><code>let uid = Symbol.for(&quot;uid&quot;);
let object = {};

object[uid] = &quot;123456&quot;;
let uid2 = Symbol.for('uid');

console.log(Symbol.keyFor(uid));//&quot;uid&quot;
console.log(Symbol.keyFor(uid2));//&quot;uid&quot;
console.log(Symbol.keyFor(uid3));//&quot;undefined&quot;
</code></pre>
<br/>
<p>symbol全局注册表是一个类似全局作用域的共享环境，也就是说你不能假设目前环境中存在哪些键。当使用第三方组件时，尽量使用Symbol键的命名空间以减少命名冲突，也即加上前缀。额外注意的一点是：这个注册中心是跨域的，意味着 iframe 或者sevice worker 中的 Symbol 会与当前 frame Symbol 相等。</p>
<br/>
<h2 id="well-konw-symbol-暴露内部操作">well-konw symbol 暴露内部操作</h2>
<p>ECMAScript5 的一个中心主旨是将JavaScript中的一些“神奇”的部分暴露出来，并详尽定义了这些开发者们中当时模拟不了的功能。ECMAScript6延续了这个传统，新标准中主要通过中原型链上定义了与Symbol相关的属性来暴露更多的语言内部逻辑。</p>
<br/>
<p>包括</p>
<ul>
<li>Symbol.hasInstance 一个在执行instanceof 时调用的内部方法，用于检测对象的继承信息。</li>
<li>Symbol.isConcatSpreadable 一个布尔值，用于表示当传递一个集合作为<code>Array.prototype.concat()</code>方法的参数时，是否应该将集合内的元素规整到同级。</li>
<li>Symbol.iterator 一个返回迭代器的方法。</li>
<li>Symbol.match 一个在调用<code>String.prototype.match()</code>方法时调用的方法，用于比较字符串。</li>
<li>Symbol.replace 一个在调用 <code>String.prototype.replace()</code>方法时调用的方法，同于替换字符串的子串。</li>
<li>Symbol.search 一个在调用<code>String.prototype.search()</code>方法时调用的方法，用于字符串中定位子串。</li>
<li>Symbol.split 一个在调用<code>String.prototype.split()</code>方法时调用的方法，用于分割字符串。</li>
<li>Symbol.toPrimitive 一个返回对象原始值的方法。</li>
<li>Symbol.toStringTag 一个在调用 <code>Object.prototype.toString()</code>方法时使用的字符串，用于创建对象描述。</li>
<li>Symbol.unscopables 一个定义了一些不可被with语句引用的对象属性名称的对象集合。</li>
</ul>
<p>重写一个由<code>well-known Symbol</code>定义的方法，会导致对象内部的默认行为被改变，从而一个普通对象会变成一个奇异对象（exotic object）。但实际上其不会对你的代码产生任何影响，只是在规范中描述对象的方式改变了。</p>
<br/>
<h3 id="symbolhasinstance-方法">Symbol.hasInstance 方法</h3>
<br/>
<p>每一个函数中都有一个<code>Symbol.hasInstance</code>方法，用于确定对象是否为函数的实例。该方法在<code>Function.prototype</code>中定义，所以所有的函数都继承了<code>instance</code>属性的默认行为。为了确保      <code>Symbol.hasInstance</code>不会被意外重写，该方法被定义为不可写，不可配置并且不可枚举。</p>
<br/>
<p><code>Symbol.hasInstance</code>方法只接受一个参数，即要检查的值。如果传入的值是函数的实例，则返回true。</p>
<pre><code>obj instanceof Array;
</code></pre>
<p>等同于</p>
<pre><code>Array[Symbol.hasInstance](obj);
</code></pre>
<p>本质上，ECMAScript6只是将instanceof操作符重新定义为此方法的简写语法。现在引入方法调用后，就可以随意改变instanceof的运行方式了。</p>
<br/>
<p>举个🌰，假设你想定义☝️无实例的函数，就可以将<code>Symbol.hasInstance</code>的返回值硬编码为false。</p>
<pre><code>function MyObject() {
    //空函数
}

Object.defineProperty(MyObject,Symbole.hasInstance,{
    value: function(v) {
        return false;
    }
});

let obj = new MyObject();

console.log(obj instanceof MyObject);   //false
</code></pre>
<p>只有通过<code>Object.defineProperty()</code>方法才能够改写一个不可写属性，上面的示例调用方法来改写<code>Symbol.hasInstance</code>,为其定义一个总是返回false的新函数，即使obj实际上确实是MyObject类的实例，在调用过<code>Object.defineProperty()</code>方法之后，instance运算符返回的也是false。</p>
<br/>
<p>当然，也可以基于任意条件，通过值检查来确定被检查的是否为实例。举个🌰，可以将1～100的数字定义为一个特殊数字类型的实例，具体实现的代码如下：</p>
<pre><code>function SpecialNumber() {
    // 空函数
}

Object.defineProperty(SpecialNumber,Symbol.hasInstance,{
    value: function(v) {
        return (v instance Number) &amp;&amp; (V &gt;= 1 &amp;&amp; V &lt;= 100);
    }
});

var two = new Number(2),
    zero = new Number(0);
console.log(two instanceof SpecialNumber); //true
console.log(zero instanceof SpecialNumber); //false
</code></pre>
<blockquote>
<p>也可以重写所有的内建函数（例如Date和Error函数）默认的Symbol.hasInstance属性。但是这样做的后果是代码的运行结果变得不可预期而且有可能令人感到😖，所以我们不推荐你这么做，最好的做法是，只在必要的情况下改写你自己声明的函数的Symbol.hasInstance 属性。</p>
</blockquote>
<h3 id="symbolisconcatspreadable属性">Symbol.isConcatSpreadable属性</h3>
<br/>
<p>JavaScript数组的<code>concat()</code>方法被设计用于拼接两个数组，使用方法：</p>
<pre><code>let color1 = ['red','green'],
    color2 = color1.concat(['blue','black']);

    console.log(color2.length);  //4
    console.log(color2); //['red','green','blue','black']
</code></pre>
<p><code>concat()</code>方法也可以接受非数组参数，此时该方法只会将这些参数逐一添加到数组末尾</p>
<pre><code>let color1 = ['red','green'],
    color2 = color1.concat(['blue','black'],'brown');

    console.log(color2.length);  //5
    console.log(color2); //['red','green','blue','black','brown']
</code></pre>
<p>为什么数组参数就要区分对待呢？JavaScript规范声明，凡是传入数组参数，就会自动将它们分解为独立元素。在ECMAScript6标准以前，我们根本无法调整这个特性。<br>
<br/><br>
Symbol.isConcatSpreadable 属性是一个布尔值，如果该属性值为true，则表明对象有length属性和数字键，故它的数值型属性值应该被独立添加到<code>concat()</code>调用结果中。它与其他well-known Symbol不同的是，这个Symbol属性默认情况下不会出现在标准对象中，它只是一个可选属性，用于增强作用于特定对象类型的<code>concat()</code>方法的功能，有效简化其默认特性。可以通过以下方法，定义一个<code>在concat()</code>调用中与数组行为相近的新类型。</p>
<pre><code>let collection = {
    0: 'Hello',
    1: 'world',
    length:2,
    [Symbol.isConcatSpreadable]: true
};

let messages = [ 'Hi' ].concat(collection);

console.log(messages); //['Hi,'Hello','world']
</code></pre>
<p>在这个示例中，定义来一个类数组对象 collection: 它有一个length属性，还有两个数字键，symbol.isConcatSpreadable属性为true表明属性值应当被当作独立元素添加到数组中。</p>
<blockquote>
<p>也可以在派生数组子类时将Symbol.isCaoncatSpreadable设置为false,从而防止元素在调用<code>concat()</code>方法时被分解。</p>
</blockquote>
<h3 id="正则相关的symbolmatchsymbolreplacesymbolsearch和symbolsplit属性">正则相关的Symbol.match,Symbol.replace,Symbol.search和Symbol.split属性</h3>
<br/>
<p>在JavaScript中，字符串与正则表达式通常一起出现，尤其是字符串类型的几个方法，可以接受正则表达式作为参数：</p>
<ul>
<li><code>match(regex)</code> 确定给定字符串是否匹配正则表达式regex</li>
<li><code>replace(regex,replacement)</code> 将字符串中匹配正则表达式regex的部分替换为replacement</li>
<li><code>search(regex)</code> 在字符串中定位匹配正则表达式regex的位置索引</li>
<li><code>split(regex)</code> 按照匹配正则表达式regex的元素将字符串分切，并将结果存入数组中。</li>
</ul>
<p>中ECMAScript6中，定义了与上述4个方法相对应的4个Symbol,将语言内建的RegExp对象的原生特性完全外包出来。</p>
<br/>
<ul>
<li>Symbol.match 接受一个字符串类型的参数，如果匹配成功则返回匹配元素的数组，否则返回null。</li>
<li>Symbol.replace 接受一个字符串类型的参数和一个替换用的字符串，最终依然返回一个字符串。</li>
<li>Symbol.search 接受一个字符串参数，如果匹配到内容，则返回数字类型的索引位置，否则返回-1。</li>
<li>Symbol.split 接受一个字符串参数，根据匹配内容将字符串分解，并返回一个包含分解后片段的数组。</li>
</ul>
<p>如果可以在对象中定义这些属性，即使不使用正则表达式和以正则表达式为参的方法也可以在对象中实现模式匹配。下面的示例将展示Symbol的实际用法：</p>
<pre><code>//实际上等价于 /^.{10}$/
let hasLengthOf10 = {
    [Symbol.match]: function(value) {
        return value.length === 10 ? [value] : null;
    },
    [Symbol.replace]: function(value, replacement) {
        return value.length === 10 ? replacement : value;
    },
    [Symbol.search]: function(value) {
        return value.length === 10 ? 0 : -1;
    },
    [Symbol.split]: function(value) {
        return value.length === 10 ? [, ] : [value];
    }
};

let message1 = 'Hello world', //11个字符
    message2 = 'Hello Jshn'; //10个字符

let match1 = message1.match(hasLengthOf10),
    match2 = message2.match(hasLengthOf10);

console.log(match1,match2); //null [&quot;Hello John&quot;]

let replace1 = message1.replace(hasLengthOf10),
    replace2 = message2.replace(hasLengthOf10);

console.log(replace1,replace2); //'Hello world' undefined

let search1 = message1.search(hasLengthOf10),
    search2 = message2.search(hasLengthOf10);

console.log(search1,search2); //-1 0

let split1 = message1.split(hasLengthOf10),
    split2 = message2.split(hasLengthOf10);

console.log(split1,split2); //['Hello world'] [empty]
</code></pre>
<h3 id="symboltoprimitive-方法">Symbol.toPrimitive 方法</h3>
<br/>
<p>在JavaScript引擎中，当执行特定操作时，经常会尝试将对象转化为原始值，例如，比较一个字符串和一个对象，如果使用双等号（==）运算符，对象会在比较操作执行前被转化为一个原始值。到底使用哪一个原始值以前由内部决定的，但在ECMAScript6的标准中，通过Symbol,toPrimitive方法可以更改那个暴露出来的值。</p>
<br/>
<p>Symbol.toPrimitive 方法被定义在每一个标准类型的原型上，并且规定当对象被转换为原始值时应当执行的操作。每当执行原始值转换时，总会调用Symbol.Primitive方法并传入一个值作为参数，这个值在规范中被称做类型提示（hint）。类型提示参数的值只有三种选择：“number”,&quot;string&quot;或“default”，传递这些参数时，Symbol.toprimitive返回的分别是：数字，字符串或无类型偏好的值。</p>
<br/>
<p>对于大多数标准对象，数字模式有以下特性，根据优先级的顺序排列如下：</p>
<ol>
<li>调用<code>valueOf()</code>方法，如果结果为原始值，则返回。</li>
<li>否则，调用<code>toString()方法</code>，如果结果为原始值，则返回。</li>
<li>如果再无可选的值，则抛出错误。</li>
</ol>
<p>同样，对于大多数标准对象，字符串模式有以下优先级排序：</p>
<ol>
<li>调用<code>toString()</code>方法，如果结果为原始值，则返回。</li>
<li>否则，调用<code>valueOf()</code>方法，如果结果为原始值，则返回。</li>
<li>如果再无可选的值，则抛出错误。</li>
</ol>
<p>在大多数情况下，标准对象会将默认模式按数字模式处理（除了Date对象，在这种情况下，会讲默认模式按字符串模式处理）。如果自定义 Symbol.toPrimitive方法，则可以覆盖这些默认的强制转换特性。</p>
<br/>
<blockquote>
<p>默认模式只用于==运算，+元算及给Date构造函数传递一个参数时。在大多数操作中，使用的都是字符串模式或数字模式。</p>
</blockquote>
<p>如果要覆写默认的转化特性，可以将函数的Symbol.toPrimitive属性赋值为一个新的函数，举个🌰：</p>
<pre><code>function Temperature(degrees) {
    this.degrees = degrees;
}

Temperature.prototype[Symbol.toPrimitive] = function(hint) {
    switch(hint) {
        case &quot;string&quot;:
            return this.degrees + &quot;\u00b0&quot;; 
        case &quot;number&quot;:
            return this.degrees;
        case &quot;default&quot;:
            return this.degrees + &quot; degrees&quot;;
    }
}

var freezing = new Temperature(32);

console.log(freezing + &quot;!&quot;);   //&quot;32 degrees!&quot;
console.log(freezing / 2);     //16
console.log(String(freezing))  //&quot;32°&quot;
</code></pre>
<p>新的方法根据参数hint指定的模式返回不同的值（参数hint由JavaScript引擎传入）。在字符串模式下，<code>Temperature()</code>函数返回Unicode的温度符号；在数字模式下，返回相应的数值；在默认模式下，将degress这个单词添加到数字后。</p>
<br/>
<p>每一条<code>console.log()</code>语句将触发不同的hint参数值。+运算符触发默认模式，hint被设置为“default”；/运算符触发数字模式，hint被设置为“number”；<code>String()</code>函数触发字符串模式，hint被设置为“string”。针对三种模式返回的值时可行的，但是更常见的做法是，将默认模式设置成与字符串模式或数字模式相同的处理逻辑。</p>
<br/>
<blockquote>
<p>🔒好像有点长了呢（才不是我不想再打字了），剩下部分的留给下吧！</p>
</blockquote>
<br/>
<p>to be continued🖋</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DOMAPI完全整理]]></title>
        <id>https://heihei12305.github.io/post/domapi-wan-quan-zheng-li</id>
        <link href="https://heihei12305.github.io/post/domapi-wan-quan-zheng-li">
        </link>
        <updated>2019-11-08T05:58:31.000Z</updated>
        <content type="html"><![CDATA[<p>asda，待整理</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HIndley-Milner 类型签名]]></title>
        <id>https://heihei12305.github.io/post/hindley-milner-lei-xing-qian-ming</id>
        <link href="https://heihei12305.github.io/post/hindley-milner-lei-xing-qian-ming">
        </link>
        <updated>2019-11-07T09:05:42.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<h3 id="单纯手打方便学习回顾原文请看">单纯手打，方便学习回顾，<a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch7.html#%E5%88%9D%E8%AF%86%E7%B1%BB%E5%9E%8B">原文请看</a></h3>
<h3 id="类型签名type-signatures">类型签名(type signatures)</h3>
</blockquote>
<p>类型(type)是让所有不同背景的人都能高效沟通的元语言。很大程度上，类型签名是以&quot;HIndley-Milner&quot;系统写就的。<br/><br>
类型签名在写纯函数时所起的作用非常大。这些签名轻述着函数最不可告人的秘密。短短一行，就能暴露函数的行为和目的。类型签名还衍生出了&quot;自由定理(free theorems)&quot;的概念。因为类型是可以推断的，所以明确的类型签名并不是必要的；不过你完全可以写精确度很高的类型签名，也可以让它们保持通用，抽象。类型签名不但可以用于编译时检测(compile time checks)，还是最好的文档。所以类型签名在函数式编程中扮演着非常重要的角色--重要程度远远超过你的想象。<br/></p>
<blockquote>
<h3 id="hindley-milner类型签名">Hindley-Milner类型签名</h3>
</blockquote>
<pre><code>// capitalize :: String -&gt; String
var capitalize = function(s){
	return toUpperCase(head(s)) + toLowerCase(tail(s));
}

capitalize(&quot;smurf&quot;);
// =&gt; &quot;smurf&quot;
</code></pre>
<p>这里，<code>capitalize</code> 接受一个 <code>String</code>并返回了一个 <code>String</code>。<br>
<br/><br>
在Hindley-Milner系统中，函数都写成类型<code>a-&gt;b</code>这个样子，其中<code>a</code>和<code>b</code>是任意类型的变量。因此，<code>capitalize</code>函数的类型签名可以理解成&quot;一个接受<code>String</code>返回<code>String</code>的函数&quot;。换句话说，它接受一个<code>String</code>类型作为输入，并返回一个<code>String</code>类型的输出。<br/></p>
<pre><code>
// match :: Regex -&gt; string -&gt; [String]
var match = curry(function(reg,s){
	return s.match(reg);
});

</code></pre>
<p>不过在还不完全了解细节的条件下，你尽可以把最后一个类型视作返回值。那么<code>match</code>函数就可以这么理解： 它接受一个<code>Regex</code>和一个<code>String</code>，返回一个<code>[String]</code>。</p>
<br/>
<p>对于上面的match函数我们完全可以把它的类型签名这样分组：</p>
<br/>
<pre><code>//match :: Regex -&gt; (String-&gt; [String])
var match = curry(function(reg,s){
	return s.match(reg);
});
</code></pre>
<p>把最后两个类型包在括号里就能反映更多的信息了。现在我们可以看出<code>match</code>这个函数接受一个<code>Regex</code>作为参数，返回一个从<code>String</code>到<code>[String]</code>的函数。因为 curry 造成的结果就是这样：给<code>match</code>一个<code>Regex</code>，得到一个新函数，能够处理其<code>String</code>参数。</p>
<br/>
<p>最后：</p>
<pre><code>// id :: a -&gt; a
var id  = function(x){ return x; }

//map :: (a -&gt; b) -&gt; [a] -&gt; [b]
var map = curry(function(f,xs)){
	return xs.map(f);
});
</code></pre>
<p>这里的<code>id</code>函数接受任意类型的<code>a</code>并返回一个类型的数据。和普通代码一样，我们也可以在类型签名中使用变量。把变量命名为<code>a</code>和<code>b</code>只是一种约定俗成的习惯，你可以使用任何你喜欢的名称。对于相同的变量名，其类型也一定相同。这是非常重要的原则，所以我们必须重申：<code>a -&gt; b</code>可以是从任意类型中<code>a</code>到任意类型<code>b</code>，但是<code>a -&gt; a</code>必须是同一类型。例如，<code>id</code><br>
可以是<code>String -&gt; String</code>，也可以是<code>Number -&gt; Number</code>，但不能是<code>String -&gt; Bool</code>。</p>
<br/>
<p>相似地，<code>map</code>也使用了变量，只不过这里的<code>b</code>可能与<code>a</code>类型相同，也可能不相同。我们可以这么理解：<code>map</code>接受两个参数，第一个是从任意类型<code>a</code>到任意类型<code>b</code>的函数；第二个是一个数组，元素是任意类型的<code>a</code>;<code>map</code>最后返回的是一个类型<code>b</code>的数组。</p>
<br/>
<pre><code>// reduce :: (b -&gt;  a -&gt; b) -&gt; b -&gt; [a] -&gt; b
var reduce = curry(function(f,x,xs){
	return xs.reduce(f, x);
});
</code></pre>
<p>&quot;here goes nothing&quot; , 可以看出它的第一个参数是一个函数，这个函数接受一个<code>b</code>和一个<code>a</code>并返回一个<code>b</code>。那么这些<code>a</code>和<code>b</code>是从哪来的呢？很简单，签名中的第二个和第三个参数就是<code>b</code>和元素为<code>a</code>的数组，所以唯一合理的假设就是这里的<code>b</code>和每一个<code>a</code>都将传给前面说的函数作为参数。我们还可以看到，<code>reduce</code>函数最后返回的结果是一个<code>b</code>，也就是说，<code>reduce</code>的第一个参数函数的输出就是<code>reduce</code>函数的输出。</p>
 <br/>
<blockquote>
<h3 id="缩小可能性范围">缩小可能性范围</h3>
</blockquote>
<p>一旦引入一个类型变量，就会出现一个奇怪的特性叫做：parametricity。这个特性表明，函数将会以一个统一的行为作用于所有的类型。</p>
<pre><code>// head :: [a] -&gt; a
</code></pre>
<p>注意看 <code>head</code>，可以看到它接受<code>[a]</code>返回<code>a</code>。我们除了知道参数是个数组，其他一概不知；所以函数的功能就只限于操作这个数组上。在它对<code>a</code>一无所知的情况下，它可能对<code>a</code>进行什么操作呢?换句话说，<code>a</code>告诉我们它不是一个特定的类型，这意味着它们可以是任意类型；那么我们的函数对每一个可能的类型的操作都必须保持统一。这就是parametricity的含义。要让我们来猜测<code>head</code>的实现的话，唯一合理的推断就是它返回数组的第一个，或者最后一个，或者某个随机的元素；当然，<code>head</code>这个命名应该能给我们一些线索。</p>
<blockquote>
<h3 id="自由定理">自由定理</h3>
</blockquote>
<p>类型签名除了能够帮助我们判断函数可能的实现，还能够给我们带来自由定理（free theorems）。</p>
<br/>
<pre><code>// head :: [a] -&gt; a
compose(f,head) == compose(head, map(f));

//filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
compose(map(f),filter(compose(p,f))) == compose(filter(p),map(f));
</code></pre>
<p>第一个例子中，等式左边说的是，先获取数组的头部，然后对它调用函数f;等式右边说的是，先对数组中的每一个元素调用f，然后再取其返回结果的头部，这两个表达式是相等的，但是前者要快得多。</p>
<br/>
<p>你可能会想，这不是常识么，但计算机是没有常识的。实际上，计算机必须要有一种形式化方法来自动进行类似的代码优化。数学提供了这种方法，能够形式化直观的感觉，这无疑对死板的计算机逻辑非常有用。</p>
<br/>
<blockquote>
<h3 id="类型约束">类型约束</h3>
</blockquote>
<p>签名也可以把类型约束成一个特定的接口</p>
<pre><code>// sort :: ord a =&gt; [a] -&gt; [a]
</code></pre>
<p>胖箭头左边表明的是这么一个事实：<code>a</code>一定是个<code>ord</code>对象。也就是说，<code>a</code>必须要实现<code>ord</code>接口。<code>ord</code>到底是什么？它从哪里来？在一门强类型语言中，它可能就是一个自定义的接口，能够让不同的值排序。通过这种方式，我们不仅能够获取关于<code>a</code>的更多信息，了解<code>sort</code>函数具体要干什么，而且还能限制函数的作用范围。我们把这种接口声明叫做类型约束(type constraints)</p>
<pre><code>// assertEqual :: (Eq a , Show a) =&gt; a -&gt; a -&gt; Assertion
</code></pre>
<p>这个例子中有两个约束： <code>Eq</code> 和 <code>Show</code> 。它们保证了我们可以检查不同的<code>a</code>是否相等， 并在有不相等的情况下打印出其中的差异。</p>
<blockquote>
<h3 id="总结">总结</h3>
</blockquote>
<p>Hindley-Milner 类型签名在函数式编程中无处不在，它们简单易读，写起来也不复杂。但仅仅凭签名就能理解整个程序还是有一定难度的，要想精通这个技能就更要花点时间了。</p>
]]></content>
    </entry>
</feed>