<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://heihei12305.github.io</id>
    <title>heihei12305</title>
    <updated>2020-04-06T11:18:12.593Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://heihei12305.github.io"/>
    <link rel="self" href="https://heihei12305.github.io/atom.xml"/>
    <subtitle>所见即所得，所见即所碍</subtitle>
    <logo>https://heihei12305.github.io/images/avatar.png</logo>
    <icon>https://heihei12305.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, heihei12305</rights>
    <entry>
        <title type="html"><![CDATA[vue 源码原理部分  依赖收集]]></title>
        <id>https://heihei12305.github.io/post/vue-yuan-ma-yuan-li-bu-fen-yi-lai-shou-ji/</id>
        <link href="https://heihei12305.github.io/post/vue-yuan-ma-yuan-li-bu-fen-yi-lai-shou-ji/">
        </link>
        <updated>2020-04-06T10:35:36.000Z</updated>
        <content type="html"><![CDATA[<p>在 getter 中收集依赖，在 setter 中触发依赖</p>
<pre><code>fucntion defineReactive(data, key, val) {
    const dep = [] //新增
    Object.defineProperty(data, key {
        enumerable: true,
        configurable: true,
        get: fucntion() {
            dep.push(window.target) //新增
            return val;
        },
        set: function(newVal) {
            if(val === newVal) {
                return ;
            }

            for(let i = 0;i &lt; dep.length; i++) {
                dep[i](newVal, val);
            }
            val = newVal;
        }
    })
}
</code></pre>
<p>这里我们新增了数组dep，用来存储被收集的依赖。<br>
然后在set被触发时，循环dep以触发收集到的依赖</p>
<p>更好的解耦版本<br>
把依赖收集的代码封装成一个Dep类，它专门帮助我们使用这个类，我们可以收集依赖，删除依赖或者向依赖发送通知等。</p>
<pre><code>export default class Dep {
    constructor () {
        this.subs = [];
    }

    addSub (sub) {
        this.subs.push(sub);
    }

    removeSub(sub) {
        if(window.target) {
            this.addSub(window.target);
        }
    }

    notify () {
        const subs = this.subs.slice();
        for(let i = 0, len = subs.length;i&lt;len;i++) {
            subs[i].update();
        }
    }
}

function remove (arr, item) {
    if(arr.length) {
        const index = arr.indexOf(item);
        if(index &gt; -1) {
            return arr.splice(index, 1);
        }
    }
}

function defineReactive (data, key, val) {
    const dep = new Dep();
    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get: function () {
            dep.depend();
            return val;
        },
        set: function () {
            if(val === newVal) {
                return;
            }
            val = newVal;
            dep.notify(); //新增
        }
    })
}
</code></pre>
<p>依赖收集到哪了？收集到Dep中了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[es2019有什么新功能？]]></title>
        <id>https://heihei12305.github.io/post/es10-de-xin-te-xing-hui-zong/</id>
        <link href="https://heihei12305.github.io/post/es10-de-xin-te-xing-hui-zong/">
        </link>
        <updated>2020-04-05T03:43:09.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文类似一篇翻译，原文在这：<a href="https://medium.com/@selvaganesh93/javascript-whats-new-in-ecmascript-2019-es2019-es10-35210c6e7f4b">https://medium.com/@selvaganesh93/javascript-whats-new-in-ecmascript-2019-es2019-es10-35210c6e7f4b</a></p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://heihei12305.github.io/post-images/1586059508146.png" alt="" loading="lazy"></figure>
<h3 id="1-arrayflat">1. Array.Flat()</h3>
<h4 id="简介">简介</h4>
<p>数组扁平化，可以设置层级，具体推荐阅读讶羽的这篇blog:<a href="https://github.com/mqyqingfeng/Blog/issues/36">https://github.com/mqyqingfeng/Blog/issues/36</a></p>
<h4 id="简要实例">简要实例</h4>
<pre><code>[1,[2,[3]]].flat() // [1, 2 ,[3]]
[1,[2,[3]]].flat(2) //[1, 2, 3]
[1,[2,[3]]].flat(Infinity) //[1,2,3]
</code></pre>
<h3 id="2-arrayflatmap">2. Array.flatMap()</h3>
<h4 id="简介-2">简介</h4>
<p>相当于在原有map的基础上叠加了flat功能, 不过无法设置层级只能扁平一层</p>
<h4 id="简要实例-2">简要实例</h4>
<pre><code>const arr = [1, 2, 3];
arr.map(x =&gt; [x, x*2]); //[[1,2],[3,4],[5,6]]
arr.map(x =&gt; [x, x*2]).flat(); // [1, 2, 2, 4, 3, 6]
</code></pre>
<h3 id="3-objectfromentries">3. Object.fromEntries()</h3>
<h4 id="简介-3">简介</h4>
<p>fromEntries方法将键值对列表转换为对象。</p>
<blockquote>
<p>注意 Object.fromEntries 仅接受可迭代，它只会接受Map或Array</p>
</blockquote>
<h4 id="简要实例-3">简要实例</h4>
<pre><code>const arr = [['a',1],['b',2]];
Object.fromEntries(arr);//{a: 1, b: 2}
</code></pre>
<h3 id="4-stringtrimstart-stringtrimend">4. String.trimStart() &amp; String.trimEnd()</h3>
<h4 id="简介-4">简介</h4>
<p>去除头部或者尾部空格</p>
<p>为什么有了trimLeft &amp; trimRight还会有trimStart &amp; trimEnd呢？</p>
<blockquote>
<p>为了与 String.prototype.padStart 等函数保持一致，标准方法名称为trimStart。 但是，出于 Web 兼容性原因，trimLeft 仍然是 trimStart 的别名。在某些引擎中，这意味着：<code>String.prototype.trimLeft.name === &quot;trimStart&quot;;</code></p>
<p align="right">--MDN</p>
</blockquote>
<h4 id="简要实例-4">简要实例</h4>
<pre><code>'    a'.trimStart(); //'a'
'a    '.trimEnd()
</code></pre>
<h3 id="5-可选捕获参数">5. 可选捕获参数</h3>
<h4 id="简介-5">简介</h4>
<p>catch可以不用必须带有时用不上的参数啦。</p>
<pre><code>try{

}catch(unUsed) {

}
</code></pre>
<p>像上文的代码，如果你使用了 eslint 或者其它的工具则会报告一个警告或者错误，但是又不得不写，就很难受……</p>
<p><code>catch(e){}</code>和<code>catch{}</code>底层处理肯定大有可究之处，可惜笔者学艺不精，分析不下去，😭</p>
<blockquote>
<p>ecma对应链接：<a href="https://tc39.es/proposal-optional-catch-binding/">https://tc39.es/proposal-optional-catch-binding/</a></p>
</blockquote>
<h4 id="简要实例-5">简要实例</h4>
<pre><code>try{

}catch{

}
</code></pre>
<h3 id="6-functiontostring">6. Function.toString()</h3>
<h4 id="简介-6">简介</h4>
<p>该toString()方法返回一个表示函数源代码的字符串。</p>
<h4 id="简要实例-6">简要实例</h4>
<pre><code>function func(){
console.log(1)
//lalal
    //lal
}
func.toString()
//  &quot;function func(){
//  //console.log(1)
//  //lalal
//     //lal
}&quot;
</code></pre>
<h3 id="7-symboldescription">7. Symbol.description</h3>
<h4 id="简介-7">简介</h4>
<p>只读description属性是一个字符串，返回Symbol对象的可选描述。</p>
<h4 id="简要实例-7">简要实例</h4>
<pre><code>const sym = Symbol('heihei');
sym.description // &quot;heihei&quot;
</code></pre>
<h3 id="8-格式良好的jsonstringify">8, 格式良好的JSON.stringify()</h3>
<h4 id="简介-8">简介</h4>
<p>返回JSON.stringify返回格式错误的Unicode字符串</p>
<h4 id="简要实例-8">简要实例</h4>
<pre><code>JSON.stringify('\uD834\uDF06') //&quot;&quot;𝌆&quot;&quot;
</code></pre>
<h3 id="9-数组排序的稳定性">9, 数组排序的稳定性</h3>
<h4 id="简介-9">简介</h4>
<p>以前，v8对10个及以上元素的数组使用不稳定的quickSort(这块可以看讶羽的<a href="https://github.com/mqyqingfeng/Blog/issues/52">https://github.com/mqyqingfeng/Blog/issues/52</a>), 从V8 v7.0/chrome 70 开始，V8使用稳定的<em>Timsort</em>算法<br>
评分相同的用户将保持其排序顺序</p>
<h4 id="简要实例-9">简要实例</h4>
<pre><code>const usersList = [
    {name:'heihei1',rating: 1},
    {name:'heihei2',rating: 2},
    {name:'heihei3',rating: 1},
    {name:'heihei4',rating: 2}
]
usersList.sort((a,b)=&gt;a.rating-b.rating)
// 0: {name: &quot;heihei1&quot;, rating: 1}
// 1: {name: &quot;heihei3&quot;, rating: 1}
// 2: {name: &quot;heihei2&quot;, rating: 2}
// 3: {name: &quot;heihei4&quot;, rating: 2}
</code></pre>
<h3 id="10-json-ecmascript">10, JSON ⊂ ECMAScript</h3>
<h4 id="简介-10">简介</h4>
<p>将ECMA-262语法扩展为JSON的超集。ecma对应链接 <a href="https://tc39.es/proposal-json-superset/">https://tc39.es/proposal-json-superset/</a></p>
<blockquote>
<p>JSON语法由ECMA-404定义，并由RFC 7159永久固定，但是ECMA-262 的DoubleStringCharacter和SingleStringCharacter生产可以扩展为允许不转义的U + 2028 LINE SEPARATOR和U + 2029 PARAGRAPH SEPARATOR字符。</p>
<p align="right"> --原文直接搬运</p>
</blockquote>
<h4 id="简要实例-10">简要实例</h4>
<pre><code>const usersList = [
    {name:'heihei1',rating: 1},
    {name:'heihei2',rating: 2},
    {name:'heihei3',rating: 1},
    {name:'heihei4',rating: 2}
]
usersList.sort((a,b)=&gt;a.rating-b.rating)
// 0: {name: &quot;heihei1&quot;, rating: 1}
// 1: {name: &quot;heihei3&quot;, rating: 1}
// 2: {name: &quot;heihei2&quot;, rating: 2}
// 3: {name: &quot;heihei4&quot;, rating: 2}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[electron初体验 - 番茄钟开发]]></title>
        <id>https://heihei12305.github.io/post/electron-chu-ti-yan-fan-qie-zhong-kai-fa/</id>
        <link href="https://heihei12305.github.io/post/electron-chu-ti-yan-fan-qie-zhong-kai-fa/">
        </link>
        <updated>2020-04-04T15:02:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>今天猛的发现, 上一篇博客居然是近一个月了。心里有点感概，时间真的不经意间遛的飞快。</p>
</blockquote>
<h3 id="前言">前言</h3>
<p>最近突然发现electron，一个可以开发桌面端应用的js框架，很感兴趣，开整开整！</p>
<h4 id="预期目标">预期目标😇</h4>
<ul>
<li>整点好玩的东西出来</li>
<li>借此了解下node，原生UI</li>
<li>放飞想象力，js很强很强💪</li>
</ul>
<h3 id="why-electron">why electron</h3>
<ul>
<li>这是一个没有ie的世界，只需要对chrome负责，可以大胆使用chrome的最新的Feature
<ul>
<li>
<p>纯天然lazy load  <code>loading=&quot;lazy&quot;</code> demo页： <a href="https://mathiasbynens.be/demo/img-loading-lazy">https://mathiasbynens.be/demo/img-loading-lazy</a></p>
</li>
<li>
<p>BigInt</p>
</li>
<li>
<p>flat, padStart 等新特性</p>
</li>
</ul>
</li>
</ul>
<h3 id="使用的库">使用的库</h3>
<ul>
<li>timer.js</li>
<li>progressbar.js</li>
</ul>
<p>不想写了，😭，放个github链接算了：<br>
<a href="https://github.com/heihei12305/Pomodoro-">https://github.com/heihei12305/Pomodoro-</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[lodash源码系列-concat]]></title>
        <id>https://heihei12305.github.io/post/lodash_concat/</id>
        <link href="https://heihei12305.github.io/post/lodash_concat/">
        </link>
        <updated>2020-03-08T08:20:44.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>所见即所得，所见即所碍</p>
</blockquote>
<p>系列概述：</p>
<ul>
<li>阅读lodash源码，并做适当笔记</li>
<li>手抄一份，学习其中实现的小技巧</li>
<li>尽量比较出与原生方法的区别</li>
</ul>
<h3 id="1-函数效果">1. 函数效果</h3>
<h4 id="测试代码">测试代码</h4>
<pre><code>const _ = require('lodash')

const vec = [1,2,3,4,5];
const a = {
 a: 1
}
const vec2 = _.concat(vec,2,a);
console.log(vec); //[ 1, 2, 3, 4, 5 ]
console.log(vec2);  //[ 1, 2, 3, 4, 5, 2, { a: 1 } ]
a.a = 2;
console.log(vec2); //[ 1, 2, 3, 4, 5, 2, { a: 2 } ]
</code></pre>
<h4 id="效果描述">效果描述：</h4>
<p><code>_.concat(array, [values])</code><br>
创建一个新数组，将array与任何数组 或 值 连接在一起</p>
<p>注意：</p>
<ol>
<li>产生一个新的数组（⚠️这一定程度上导致了较push性能不是很好）</li>
<li>浅拷贝</li>
</ol>
<h3 id="2-手抄代码">2. 手抄代码</h3>
<h4 id="导入功能代码">导入功能代码：</h4>
<p>列举</p>
<ul>
<li>arrayPush</li>
<li>baseFlatten</li>
<li>copyArray</li>
<li>isArray</li>
</ul>
<p>比较有趣的地方：</p>
<p>拷贝数组</p>
<pre><code>fucntion copyArray(source, array) {
    let index = -1, length = source.length;
    //利用短路求值特性，实现守护功能
    array || (array = Array(length);
    while(++index &lt; length) {
        array[index] = source[index];
    }
    return array;
}
</code></pre>
<p>数组扁平化 （细节待flatten再说）</p>
<pre><code>function baseFlatten(array, depth, predicate, isStrict, result) {
    const index = -1, length = array.length;

    predicate || (predicate = isFlattenable);
    result || (result = []);

    while(++index &lt; length) {
        let value = array[index];
        if(depth &gt; 0 &amp;&amp; predicate(value)) {
            if(depth &gt; 1) {
                //递归啦递归啦
                baseFlatten(value, depth-1, predicate, isStrict, result);
            } else {
                arrPush(result, value);
            }
        } else if(!isStrict) {
            // 什么数据会触发这个呢？ ⚠️待解决
            result[result.length] = value;
        }
    }
    return rsult;
}
</code></pre>
<h4 id="主要代码">主要代码</h4>
<pre><code>function concat() {
    let length = arguments.length;
    if(!length) {
        return [];
    }

    let args = Array(length - 1),
            array = argument[0],
            index = length;

    //细品，比平时少了个变量，但一切刚刚好，👍
    while (index--) {
        args[index - 1] = arguments[index];
    }

    return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));

}
</code></pre>
<h3 id="3-技巧总结">3. 技巧总结</h3>
<ul>
<li>短路求值</li>
</ul>
<pre><code>//例
predicate || (predicate = isFlattenable);
</code></pre>
<ul>
<li>赋值，从后向前</li>
</ul>
<pre><code>//例

while (index--) {
    args[index - 1] = arguments[index];
}
</code></pre>
<p>不过这种单纯赋值操作，更直观的还是用slice, splice来实现吧</p>
<pre><code>//例
vec.slice(1);
vec.splice(1)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[http-proxy-middleware 跨域跨域跨域]]></title>
        <id>https://heihei12305.github.io/post/http-proxy-middleware-kua-yu-kua-yu-kua-yu/</id>
        <link href="https://heihei12305.github.io/post/http-proxy-middleware-kua-yu-kua-yu-kua-yu/">
        </link>
        <updated>2020-02-16T09:44:37.000Z</updated>
        <content type="html"><![CDATA[<p>配置 https 跨域<br>
src/setupProxy.js</p>
<pre><code>const proxy = require('http-proxy-middleware');

module.exports = function(app) {
  app.use(proxy('/v1/token', {
     target: 'https://oauth.aliyun.com/',
     &quot;secure&quot;: false,
     &quot;changeOrigin&quot;: true
    }));
};

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2019/1/27-2020/2/27 --一个月春招突击计划]]></title>
        <id>https://heihei12305.github.io/post/2019127-2020227-yi-ge-yue-chun-zhao-tu-ji-ji-hua/</id>
        <link href="https://heihei12305.github.io/post/2019127-2020227-yi-ge-yue-chun-zhao-tu-ji-ji-hua/">
        </link>
        <updated>2020-01-27T09:12:24.000Z</updated>
        <content type="html"><![CDATA[<h3 id="当前处境">当前处境：</h3>
<ul>
<li>
<p>武汉出事，全国戒严，也不知道什么时候能去公司，有点心疼房租，不对跑题了，可能在家会待的久一些。</p>
</li>
<li>
<p>书基本看的差不多了，然后 极客时间 专栏也差不多了。</p>
</li>
<li>
<p>技术栈到位</p>
</li>
<li>
<p>项目到位</p>
</li>
</ul>
<p>突击一个月，只奔大厂去。</p>
<h3 id="一个月目标">一个月目标</h3>
<ul>
<li>leetcode 400</li>
<li>重学前端 三刷</li>
<li>css世界 三刷</li>
<li>趣谈网络协议 三刷</li>
<li>javaScript核心原理解析 二刷</li>
<li>你不知道的jsvaScript 三刷</li>
<li>各种面试题集</li>
<li>讶羽博客汇总 三刷</li>
<li>wtfjs 三刷</li>
</ul>
<h3 id="具体安排">具体安排：</h3>
<p>因为时间并不是很确定，暂定</p>
<p>在家时：</p>
<ul>
<li>上午 重学前端  音频➕文字 &amp; wtfjs</li>
<li>下午leetcode 2道左右 &amp; 各种面经</li>
<li>晚上 红宝书 阅读 ｜ css选择器世界阅读 &amp; <s>讶羽博客汇总</s> ✅  掘金小册 性能优化-修言</li>
</ul>
<blockquote>
<p>所见即所得，所见即所碍。春招，加油⛽️</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[👀github博客不能翻页？快速生成gitbook了解一下]]></title>
        <id>https://heihei12305.github.io/post/github-bo-ke-bu-neng-fan-ye-kuai-su-sheng-cheng-gitbook-liao-jie-yi-xia/</id>
        <link href="https://heihei12305.github.io/post/github-bo-ke-bu-neng-fan-ye-kuai-su-sheng-cheng-gitbook-liao-jie-yi-xia/">
        </link>
        <updated>2020-01-19T06:47:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="预期效果先来一波">预期效果先来一波</h3>
<figure data-type="image" tabindex="1"><img src="https://heihei12305.github.io/post-images/1579417038963.gif" alt="" loading="lazy"></figure>
<p>😼是不是心动啦，各位大佬的github博客质量那是相当高，就是不能翻页，看完一个还要回到首页README链接🔗，感觉不太友好。尤其像我这样不是第一遍看👀，想回顾一下的🧍‍♂️，无法满足快速翻阅的需求。</p>
<p>让我们开始吧！</p>
<h3 id="首先找到你喜欢的github项目star-fork-一条龙我寻思着这个就不用再多余赘述了吧">首先，找到你喜欢的github项目，star, fork 一条龙，我寻思着这个就不用再多余赘述了吧。</h3>
<hr>
<h3 id="然后打开-gitbook注册登陆创建空间巴拉巴拉的-看下面的">然后打开 gitbook，注册登陆，创建空间，巴拉巴拉的。 👇看下面的📃</h3>
<figure data-type="image" tabindex="2"><img src="https://heihei12305.github.io/post-images/1579417640747.gif" alt="" loading="lazy"></figure>
<h3 id="然后就是简单的创建space环节了-gitbook可以免费创建一个组织一个-个人空间-想必是可以满足大多数人的需求的呢">然后就是🔜，简单的创建space环节了。gitbook可以免费创建一个组织，一个 个人空间 ，想必是可以满足大多数人的需求的呢！😸</h3>
<figure data-type="image" tabindex="3"><img src="https://heihei12305.github.io/post-images/1579417946901.gif" alt="" loading="lazy"></figure>
<h3 id="最后就是简单快速的链接github仓库一键生成了">最后，就是简单快速的链接🔗github仓库，一键生成了！</h3>
<blockquote>
<p>因为比较慢，分成多个gif展示了</p>
</blockquote>
<ol>
<li>🔗链接进行中</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://heihei12305.github.io/post-images/1579418320995.gif" alt="" loading="lazy"></figure>
<ol start="2">
<li>选择仓库</li>
</ol>
<figure data-type="image" tabindex="5"><img src="https://heihei12305.github.io/post-images/1579418436486.gif" alt="" loading="lazy"></figure>
<ol start="3">
<li>✅，成果展示！<br>
<img src="https://heihei12305.github.io/post-images/1579419486223.gif" alt="" loading="lazy"></li>
<li>gitbook 也有提供可阅读外链呢！为了不影响各位大大blog 的star数量，我就不贴我自己做的gitbook 阅读链接🔗了！大家可以自行star, fork制作呢！<br>
<img src="https://heihei12305.github.io/post-images/1579419767657.gif" alt="" loading="lazy"></li>
</ol>
<hr>
<h3 id="总结">总结：</h3>
<p>使用gitbook优势:</p>
<ul>
<li>方便阅读，方便阅读，方便阅读！github不能翻页真滴难受。</li>
<li>加载速度较 github 快很多</li>
<li>方便快速回忆性浏览</li>
</ul>
<p>使用gitbook劣势：</p>
<ul>
<li>无法看到 大佬 blog 底下的评论</li>
<li>gitbook制作需要翻墙</li>
</ul>
<p>最佳实践：<br>
第一次👀时，建议在github上，star，fork一条龙，毕竟大佬们都付出了巨大精力来写这些blog。如果blog价值很高，需要多次回顾，建议搞成gitbook小书，方便阅读。</p>
<p>🙏谢谢阅读！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iTerm2 快捷命令]]></title>
        <id>https://heihei12305.github.io/post/iterm2-kuai-jie-ming-ling/</id>
        <link href="https://heihei12305.github.io/post/iterm2-kuai-jie-ming-ling/">
        </link>
        <updated>2020-01-14T14:46:12.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>command + t 新建标签🏷️<br>
<img src="https://heihei12305.github.io/post-images/1579014351285.gif" alt="" loading="lazy"></li>
<li>command + w	关闭标签🏷️<br>
<img src="https://heihei12305.github.io/post-images/1579014370912.gif" alt="" loading="lazy"></li>
<li>command + 数字 切换标签🏷️<br>
<img src="https://heihei12305.github.io/post-images/1579014398577.gif" alt="" loading="lazy"></li>
<li>command + 左右键	切换标签🏷️<br>
<img src="https://heihei12305.github.io/post-images/1579014539217.gif" alt="" loading="lazy"></li>
<li>command + enter	切换全屏<br>
<img src="https://heihei12305.github.io/post-images/1579014417459.gif" alt="" loading="lazy"></li>
<li>command + d 垂直分屏<br>
<img src="https://heihei12305.github.io/post-images/1579015306805.gif" alt="" loading="lazy"></li>
<li>command + shift + d 水平分屏<br>
<img src="https://heihei12305.github.io/post-images/1579015319876.gif" alt="" loading="lazy"></li>
<li>ctrl + u	清除当前行<br>
<img src="https://heihei12305.github.io/post-images/1579015405233.gif" alt="" loading="lazy"></li>
<li>ctrl + l	清屏<br>
<img src="https://heihei12305.github.io/post-images/1579015398236.gif" alt="" loading="lazy"></li>
<li>ctrl + a	到行首 ctrl + e	到行尾<br>
<img src="https://heihei12305.github.io/post-images/1579015391632.gif" alt="" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nginx 部署]]></title>
        <id>https://heihei12305.github.io/post/nginx-bu-shu/</id>
        <link href="https://heihei12305.github.io/post/nginx-bu-shu/">
        </link>
        <updated>2020-01-11T11:15:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="启动停止和重新加载配置">启动，停止和重新加载配置</h2>
<p>一旦启动nginx，就可以通过 -s 文件 来进行控制</p>
<blockquote>
<p>nginx -s 信号</p>
</blockquote>
<p>信号可以是以下之一：</p>
<ul>
<li>stop 快速关机</li>
<li>quit 正常关机</li>
<li>reload 重新加载配置文件</li>
<li>reopen 重新打开日志文件</li>
</ul>
<h2 id="配置文件的结构">配置文件的结构</h2>
<p>nginx 由配置文件中指定的指令控制的模块组成。伪指令分为简单伪指令和块伪指令。<br>
一个简单的指令由名称和参数组成，这些名称和参数之间用空格分隔，并以分号（；）结尾。<br>
块指令的结果与简单指令的结构相同，但是它是用括号（{,}）起来的附加指令。如果块指令在花括号内有其他其他指令，则称为上下文。<br>
放置在任何上下文外部的配置文件中的指令都被视为在主上下文中。<br>
#符号 后的其余行都被视为注释</p>
<h2 id="提供静态内容">提供静态内容</h2>
<p>Web服务器的一项重要任务是分发文件（例如图像或静态HTML页面）。</p>
<pre><code>user  nginx;
worker_processes  1;

events {
  worker_connections  4096;  ## Default: 1024
}

http {
  include  mime.types;
  server {
    listen 3000;
    location /# {
      try_files $uri /#/index.html; # l/#/index.html 路径不是真实的文件路径，而是访问的 url 路径
    }
    location = /#/index.html { # 上面的 location 都导流到了这里
      alias /usr/AD/ad_web/index.html; # 这里是真实的文件路径
      access_log              off;
      add_header              Cache-Control &quot;no-cache, no-store&quot;;
      expires                 -1;
      etag                    on;
    }
    location /static/ { # 静态文件
      # http://test.com/produk-digital/static/css/main.css
      # 会被解析成
      # /Users/youxingzhi/shopee/sniper/build/static/css/main.css
      # 如果换成 root 则会解析成
      # /Users/youxingzhi/shopee/sniper/build/static/produk-digital/static/css/main.css
      alias                 /usr/AD/ad_web/static/;
      access_log              off;
      etag                    on;
      gzip                    on;
      include                 gzip_params;
    }
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6-你真的懂symbol吗❓😸(下)]]></title>
        <id>https://heihei12305.github.io/post/es6-ni-zhen-de-dong-symbol-ma-xia/</id>
        <link href="https://heihei12305.github.io/post/es6-ni-zhen-de-dong-symbol-ma-xia/">
        </link>
        <updated>2020-01-04T08:34:44.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>所见即所得，所见即所碍。</p>
</blockquote>
<p>继续继续继续啦！😈</p>
<p>大概目录：</p>
<ul>
<li>symbol基础</li>
<li>well-konwn symbol 暴露内部操作</li>
<li>元编程</li>
</ul>
<p>内容主要来自</p>
<ul>
<li>深入理解es6</li>
<li>你不知道的javaScript下</li>
<li><a href="https://juejin.im/post/5a0e65c1f265da430702d6b9">[译]ES6 中的元编程：第一部分 —— Symbol，了不起的 Symbol</a></li>
</ul>
<h2 id="well-konwn-symbol-暴露内部操作">well-konwn symbol 暴露内部操作😺</h2>
<h3 id="symboltostringtag-属性">Symbol.toStringTag 属性</h3>
<p>js有时会同时存在多个全局执行环境，比如在Web浏览器中，如果一个页面包含iframe标签🏷️，就会分别为页面和iframe内嵌页面生成两个全局执行环境。在大多数情况下，由于数据可以在不同环境间来回传递，不太需要担心；但是如果对象在不同对象间传递之后，你想确定它的类型呢？</p>
<p>首先明确一下概念，领域指的是javaScript的执行环境，每个领域都有自己的全局作用域，有自己的全局对象，在任何领域创建的数组，都是一个正规的数组。然而，如果把这个数组传递到另一个领域中,instanceof Array 语句的检测结果会返回false，此时 Array 已是另一个领域的构造函数，显然被检测的数组不是由这个构造函数创建的。</p>
<h4 id="针对类型识别问题的解决方案">针对类型识别问题的解决方案</h4>
<p>Object.prototype 能跨越 iframe 的边界来识别数组</p>
<pre><code>function isArray(value) {
    return Object.prototype.toString.call(value) === &quot;[object Array]&quot;;
}

console.log(isArray([])); //true
</code></pre>
<h4 id="在ecmascript6-中定义对象字符串标签️">在ECMAScript6 中定义对象字符串标签🏷️</h4>
<p>ECMAScript6重新定义了原生对象过去的状态，通过 <code>Symbol.toStringTag</code>这个Symbol改变了调用<code>Object.prototype.toString()</code>时返回的身份标识。这个Symbol所代表的属性在每一个对象中都存在，其定义了调用对象的Object.prototype.toString.call()方法返回的值。对于数组，调用那个函数返回的值通常是&quot;Array&quot;,它正是存储在对象的<code>Symbol.toStringTag</code>属性中。</p>
<p>同样的，可以为你自己的对象定义<code>Symbol.toStringTag</code>的值：</p>
<pre><code>function Person(name) {
    this.name = name;
}

Person.prototype[Symbol.toStringTag] = &quot;Person&quot;;
let me = new Person(&quot;heihei&quot;);

console.log(me.toString());                                //&quot;[object Person]&quot;
console.log(Object.prototype.toString.call(me));   //&quot;[object Person]&quot;
</code></pre>
<blockquote>
<p>除非另有说明，所以对象都会从 <code>Object.prototype</code> 挤成 <code>Symbol.toStringTag</code>这个属性，且默认的属性值为&quot;Object&quot;。</p>
</blockquote>
<p>对于开发者定义的对象来说，不限制<code>Symbol.toStringTag</code>属性的值的范围。例如，语言本身不会阻止你使用Array作为<code>Symbol.toStringTag</code>属性的值</p>
<pre><code>function Person(name){
    this.name = name;
}

Person.prototype[Symbol.toStringTag] = &quot;Array&quot;;

Person.prototype.toString = function() {
    return this.name;
}

let me = new Person(&quot;heihei&quot;);

console.log(me.toString());                              //&quot;heihei&quot;
console.log(Object.prototype.toString.call(me))  //&quot;[Object Array]&quot;
</code></pre>
<p>在这段代码中，调用Object.prototype.toString() 方法得到的结果是&quot;[object Array]&quot;，跟你从一个真实数组中得到的结果完全一样。这也就意味着，<code>Object.prototype.toString()</code>不是一个十分可靠的识别对象类型的方法。</p>
<br/>
<h3 id="symbolunscopables-属性">Symbol.unscopables 属性</h3>
<blockquote>
<p>with 语句是 JavaScript 中最有争议的一个语句，设计它的初衷是可以免于编写重复的代码。但由于加入with语句后，代码变得难以理解，它的执行性能很差且容易导致程序出错，因此被大多数开发者所诟病。最终，标准规定，在严格模式下不可以使用with语句；且这条限制同样影响到了类和模块，默认使用严格模式且没有任何退出的方法。</p>
</blockquote>
<pre><code>var values = [1,2,2],
     colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;],
     color = &quot;black&quot;;

with(colors) {
    push(color);
    push(...values);
}

console.log(colors);   //&quot;[&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;black&quot;, 1, 2, 2]&quot;
</code></pre>
<p>注意上面的代码里有个values变量，但在ECMAScript 6 中，数组中添加了一个values方法。总之，在ECMAScript6环境中，with语句引用的values不是with语句外的变量values,而是数组本身的values方法，这样就脱离代码原本的目标了。因此ECMAScript 6也添加了 <code>Symbol.unscopables</code>这个Symbol来解决这个问题。</p>
<p><code>Symbol.unscopables</code>这个Symbol通常用于<code>Array.prototype</code>。以在with语句中标示出不创建绑定的属性名。<code>Symbol.unscopables</code>是以对象的形式出现的，它的键是在with语句中要忽略的标识符，其对应的值必须是 true 。这里是数组<code>Symbol.unscopables</code>属性的默认值：</p>
<pre><code>// 已默认内置到ECMAScript 6中
Array.prototype[Symbol.unscopables] = Object.assign(Object.create(null),{
    copyWithin: true,
    entries: true,
    fill: true,
    find: true,
    findIndex: true,
    keys: true,
    values: true
})
</code></pre>
<p>☠️不要为自己创建的对象定义<code>Symbol.unscopables</code>属性，除非在代码中使用了with语句并且正在修改代码库中已有的对象。</p>
<h2 id="元编程">元编程💻</h2>
<h3 id="概述️">概述⌨️</h3>
<blockquote>
<p>元编程是指操作目标是程序本身的行为特性的编程。换句话说，它是对程序的编程的编程。（体会下上面的well-known api）</p>
</blockquote>
<br/>
<blockquote>
<p>内省：一种元编程形式，举例来说，如果想要查看对象a和另外一个对象b的关系是否是<code>[[prototype]]</code>链接🔗的，可以使用<code>a.isPrototype(b)</code>。</p>
</blockquote>
<p>元编程关注以下几点：</p>
<ul>
<li>代码查看自身</li>
<li>代码修改自身</li>
<li>代码修改默认语言特性</li>
</ul>
<p>元编程的目标是利用语言本身的内省能力使代码的其余本分更具描述性，表达性和灵活性</p>
<br/>
<h3 id="元属性">元属性🖥</h3>
<blockquote>
<p>元属性以属性访问的形式提供特殊的其他方法无法获取的元信息。</p>
</blockquote>
<p>以 new.target 为🌰，关键字new用作属性访问的上下文。显然，new 本身不是一个对象，因此这个功能很特殊。而在构造器调用（通过new触发的函数/方法）内部使用new.target时，new成了一个虚拟上下文，使得new.target能够指向调用new的目标构造器。</p>
<p>这个是元编程操作的一个明显示例，因为它的目的是从构造器调用内部确定最初new的目标是什么，通用地说用于内省（检查类型/结构）或者静态属性访问。</p>
<blockquote>
<p>好吧😨，这个整不来整不来，太吃力了。留个坑，以后回来再填。👻</p>
</blockquote>
]]></content>
    </entry>
</feed>