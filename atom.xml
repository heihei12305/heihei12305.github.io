<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://heihei12305.github.io</id>
    <title>heihei12305</title>
    <updated>2020-03-08T03:42:05.155Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://heihei12305.github.io"/>
    <link rel="self" href="https://heihei12305.github.io/atom.xml"/>
    <subtitle>所见即所得，所见即所碍</subtitle>
    <logo>https://heihei12305.github.io/images/avatar.png</logo>
    <icon>https://heihei12305.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, heihei12305</rights>
    <entry>
        <title type="html"><![CDATA[http-proxy-middleware 跨域跨域跨域]]></title>
        <id>https://heihei12305.github.io/post/http-proxy-middleware-kua-yu-kua-yu-kua-yu/</id>
        <link href="https://heihei12305.github.io/post/http-proxy-middleware-kua-yu-kua-yu-kua-yu/">
        </link>
        <updated>2020-02-16T09:44:37.000Z</updated>
        <content type="html"><![CDATA[<p>配置 https 跨域<br>
src/setupProxy.js</p>
<pre><code>const proxy = require('http-proxy-middleware');

module.exports = function(app) {
  app.use(proxy('/v1/token', {
     target: 'https://oauth.aliyun.com/',
     &quot;secure&quot;: false,
     &quot;changeOrigin&quot;: true
    }));
};

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2019/1/27-2020/2/27 --一个月春招突击计划]]></title>
        <id>https://heihei12305.github.io/post/2019127-2020227-yi-ge-yue-chun-zhao-tu-ji-ji-hua/</id>
        <link href="https://heihei12305.github.io/post/2019127-2020227-yi-ge-yue-chun-zhao-tu-ji-ji-hua/">
        </link>
        <updated>2020-01-27T09:12:24.000Z</updated>
        <content type="html"><![CDATA[<h3 id="当前处境">当前处境：</h3>
<ul>
<li>
<p>武汉出事，全国戒严，也不知道什么时候能去公司，有点心疼房租，不对跑题了，可能在家会待的久一些。</p>
</li>
<li>
<p>书基本看的差不多了，然后 极客时间 专栏也差不多了。</p>
</li>
<li>
<p>技术栈到位</p>
</li>
<li>
<p>项目到位</p>
</li>
</ul>
<p>突击一个月，只奔大厂去。</p>
<h3 id="一个月目标">一个月目标</h3>
<ul>
<li>leetcode 400</li>
<li>重学前端 三刷</li>
<li>css世界 三刷</li>
<li>趣谈网络协议 三刷</li>
<li>javaScript核心原理解析 二刷</li>
<li>你不知道的jsvaScript 三刷</li>
<li>各种面试题集</li>
<li>讶羽博客汇总 三刷</li>
<li>wtfjs 三刷</li>
</ul>
<h3 id="具体安排">具体安排：</h3>
<p>因为时间并不是很确定，暂定</p>
<p>在家时：</p>
<ul>
<li>上午 重学前端  音频➕文字 &amp; wtfjs</li>
<li>下午leetcode 2道左右 &amp; 各种面经</li>
<li>晚上 红宝书 阅读 ｜ css选择器世界阅读 &amp; <s>讶羽博客汇总</s> ✅  掘金小册 性能优化-修言</li>
</ul>
<blockquote>
<p>所见即所得，所见即所碍。春招，加油⛽️</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[👀github博客不能翻页？快速生成gitbook了解一下]]></title>
        <id>https://heihei12305.github.io/post/github-bo-ke-bu-neng-fan-ye-kuai-su-sheng-cheng-gitbook-liao-jie-yi-xia/</id>
        <link href="https://heihei12305.github.io/post/github-bo-ke-bu-neng-fan-ye-kuai-su-sheng-cheng-gitbook-liao-jie-yi-xia/">
        </link>
        <updated>2020-01-19T06:47:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="预期效果先来一波">预期效果先来一波</h3>
<figure data-type="image" tabindex="1"><img src="https://heihei12305.github.io/post-images/1579417038963.gif" alt="" loading="lazy"></figure>
<p>😼是不是心动啦，各位大佬的github博客质量那是相当高，就是不能翻页，看完一个还要回到首页README链接🔗，感觉不太友好。尤其像我这样不是第一遍看👀，想回顾一下的🧍‍♂️，无法满足快速翻阅的需求。</p>
<p>让我们开始吧！</p>
<h3 id="首先找到你喜欢的github项目star-fork-一条龙我寻思着这个就不用再多余赘述了吧">首先，找到你喜欢的github项目，star, fork 一条龙，我寻思着这个就不用再多余赘述了吧。</h3>
<hr>
<h3 id="然后打开-gitbook注册登陆创建空间巴拉巴拉的-看下面的">然后打开 gitbook，注册登陆，创建空间，巴拉巴拉的。 👇看下面的📃</h3>
<figure data-type="image" tabindex="2"><img src="https://heihei12305.github.io/post-images/1579417640747.gif" alt="" loading="lazy"></figure>
<h3 id="然后就是简单的创建space环节了-gitbook可以免费创建一个组织一个-个人空间-想必是可以满足大多数人的需求的呢">然后就是🔜，简单的创建space环节了。gitbook可以免费创建一个组织，一个 个人空间 ，想必是可以满足大多数人的需求的呢！😸</h3>
<figure data-type="image" tabindex="3"><img src="https://heihei12305.github.io/post-images/1579417946901.gif" alt="" loading="lazy"></figure>
<h3 id="最后就是简单快速的链接github仓库一键生成了">最后，就是简单快速的链接🔗github仓库，一键生成了！</h3>
<blockquote>
<p>因为比较慢，分成多个gif展示了</p>
</blockquote>
<ol>
<li>🔗链接进行中</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://heihei12305.github.io/post-images/1579418320995.gif" alt="" loading="lazy"></figure>
<ol start="2">
<li>选择仓库</li>
</ol>
<figure data-type="image" tabindex="5"><img src="https://heihei12305.github.io/post-images/1579418436486.gif" alt="" loading="lazy"></figure>
<ol start="3">
<li>✅，成果展示！<br>
<img src="https://heihei12305.github.io/post-images/1579419486223.gif" alt="" loading="lazy"></li>
<li>gitbook 也有提供可阅读外链呢！为了不影响各位大大blog 的star数量，我就不贴我自己做的gitbook 阅读链接🔗了！大家可以自行star, fork制作呢！<br>
<img src="https://heihei12305.github.io/post-images/1579419767657.gif" alt="" loading="lazy"></li>
</ol>
<hr>
<h3 id="总结">总结：</h3>
<p>使用gitbook优势:</p>
<ul>
<li>方便阅读，方便阅读，方便阅读！github不能翻页真滴难受。</li>
<li>加载速度较 github 快很多</li>
<li>方便快速回忆性浏览</li>
</ul>
<p>使用gitbook劣势：</p>
<ul>
<li>无法看到 大佬 blog 底下的评论</li>
<li>gitbook制作需要翻墙</li>
</ul>
<p>最佳实践：<br>
第一次👀时，建议在github上，star，fork一条龙，毕竟大佬们都付出了巨大精力来写这些blog。如果blog价值很高，需要多次回顾，建议搞成gitbook小书，方便阅读。</p>
<p>🙏谢谢阅读！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iTerm2 快捷命令]]></title>
        <id>https://heihei12305.github.io/post/iterm2-kuai-jie-ming-ling/</id>
        <link href="https://heihei12305.github.io/post/iterm2-kuai-jie-ming-ling/">
        </link>
        <updated>2020-01-14T14:46:12.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>command + t 新建标签🏷️<br>
<img src="https://heihei12305.github.io/post-images/1579014351285.gif" alt="" loading="lazy"></li>
<li>command + w	关闭标签🏷️<br>
<img src="https://heihei12305.github.io/post-images/1579014370912.gif" alt="" loading="lazy"></li>
<li>command + 数字 切换标签🏷️<br>
<img src="https://heihei12305.github.io/post-images/1579014398577.gif" alt="" loading="lazy"></li>
<li>command + 左右键	切换标签🏷️<br>
<img src="https://heihei12305.github.io/post-images/1579014539217.gif" alt="" loading="lazy"></li>
<li>command + enter	切换全屏<br>
<img src="https://heihei12305.github.io/post-images/1579014417459.gif" alt="" loading="lazy"></li>
<li>command + d 垂直分屏<br>
<img src="https://heihei12305.github.io/post-images/1579015306805.gif" alt="" loading="lazy"></li>
<li>command + shift + d 水平分屏<br>
<img src="https://heihei12305.github.io/post-images/1579015319876.gif" alt="" loading="lazy"></li>
<li>ctrl + u	清除当前行<br>
<img src="https://heihei12305.github.io/post-images/1579015405233.gif" alt="" loading="lazy"></li>
<li>ctrl + l	清屏<br>
<img src="https://heihei12305.github.io/post-images/1579015398236.gif" alt="" loading="lazy"></li>
<li>ctrl + a	到行首 ctrl + e	到行尾<br>
<img src="https://heihei12305.github.io/post-images/1579015391632.gif" alt="" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nginx 部署]]></title>
        <id>https://heihei12305.github.io/post/nginx-bu-shu/</id>
        <link href="https://heihei12305.github.io/post/nginx-bu-shu/">
        </link>
        <updated>2020-01-11T11:15:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="启动停止和重新加载配置">启动，停止和重新加载配置</h2>
<p>一旦启动nginx，就可以通过 -s 文件 来进行控制</p>
<blockquote>
<p>nginx -s 信号</p>
</blockquote>
<p>信号可以是以下之一：</p>
<ul>
<li>stop 快速关机</li>
<li>quit 正常关机</li>
<li>reload 重新加载配置文件</li>
<li>reopen 重新打开日志文件</li>
</ul>
<h2 id="配置文件的结构">配置文件的结构</h2>
<p>nginx 由配置文件中指定的指令控制的模块组成。伪指令分为简单伪指令和块伪指令。<br>
一个简单的指令由名称和参数组成，这些名称和参数之间用空格分隔，并以分号（；）结尾。<br>
块指令的结果与简单指令的结构相同，但是它是用括号（{,}）起来的附加指令。如果块指令在花括号内有其他其他指令，则称为上下文。<br>
放置在任何上下文外部的配置文件中的指令都被视为在主上下文中。<br>
#符号 后的其余行都被视为注释</p>
<h2 id="提供静态内容">提供静态内容</h2>
<p>Web服务器的一项重要任务是分发文件（例如图像或静态HTML页面）。</p>
<pre><code>user  nginx;
worker_processes  1;

events {
  worker_connections  4096;  ## Default: 1024
}

http {
  include  mime.types;
  server {
    listen 3000;
    location /# {
      try_files $uri /#/index.html; # l/#/index.html 路径不是真实的文件路径，而是访问的 url 路径
    }
    location = /#/index.html { # 上面的 location 都导流到了这里
      alias /usr/AD/ad_web/index.html; # 这里是真实的文件路径
      access_log              off;
      add_header              Cache-Control &quot;no-cache, no-store&quot;;
      expires                 -1;
      etag                    on;
    }
    location /static/ { # 静态文件
      # http://test.com/produk-digital/static/css/main.css
      # 会被解析成
      # /Users/youxingzhi/shopee/sniper/build/static/css/main.css
      # 如果换成 root 则会解析成
      # /Users/youxingzhi/shopee/sniper/build/static/produk-digital/static/css/main.css
      alias                 /usr/AD/ad_web/static/;
      access_log              off;
      etag                    on;
      gzip                    on;
      include                 gzip_params;
    }
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6-你真的懂symbol吗❓😸(下)]]></title>
        <id>https://heihei12305.github.io/post/es6-ni-zhen-de-dong-symbol-ma-xia/</id>
        <link href="https://heihei12305.github.io/post/es6-ni-zhen-de-dong-symbol-ma-xia/">
        </link>
        <updated>2020-01-04T08:34:44.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>所见即所得，所见即所碍。</p>
</blockquote>
<p>继续继续继续啦！😈</p>
<p>大概目录：</p>
<ul>
<li>symbol基础</li>
<li>well-konwn symbol 暴露内部操作</li>
<li>元编程</li>
</ul>
<p>内容主要来自</p>
<ul>
<li>深入理解es6</li>
<li>你不知道的javaScript下</li>
<li><a href="https://juejin.im/post/5a0e65c1f265da430702d6b9">[译]ES6 中的元编程：第一部分 —— Symbol，了不起的 Symbol</a></li>
</ul>
<h2 id="well-konwn-symbol-暴露内部操作">well-konwn symbol 暴露内部操作😺</h2>
<h3 id="symboltostringtag-属性">Symbol.toStringTag 属性</h3>
<p>js有时会同时存在多个全局执行环境，比如在Web浏览器中，如果一个页面包含iframe标签🏷️，就会分别为页面和iframe内嵌页面生成两个全局执行环境。在大多数情况下，由于数据可以在不同环境间来回传递，不太需要担心；但是如果对象在不同对象间传递之后，你想确定它的类型呢？</p>
<p>首先明确一下概念，领域指的是javaScript的执行环境，每个领域都有自己的全局作用域，有自己的全局对象，在任何领域创建的数组，都是一个正规的数组。然而，如果把这个数组传递到另一个领域中,instanceof Array 语句的检测结果会返回false，此时 Array 已是另一个领域的构造函数，显然被检测的数组不是由这个构造函数创建的。</p>
<h4 id="针对类型识别问题的解决方案">针对类型识别问题的解决方案</h4>
<p>Object.prototype 能跨越 iframe 的边界来识别数组</p>
<pre><code>function isArray(value) {
    return Object.prototype.toString.call(value) === &quot;[object Array]&quot;;
}

console.log(isArray([])); //true
</code></pre>
<h4 id="在ecmascript6-中定义对象字符串标签️">在ECMAScript6 中定义对象字符串标签🏷️</h4>
<p>ECMAScript6重新定义了原生对象过去的状态，通过 <code>Symbol.toStringTag</code>这个Symbol改变了调用<code>Object.prototype.toString()</code>时返回的身份标识。这个Symbol所代表的属性在每一个对象中都存在，其定义了调用对象的Object.prototype.toString.call()方法返回的值。对于数组，调用那个函数返回的值通常是&quot;Array&quot;,它正是存储在对象的<code>Symbol.toStringTag</code>属性中。</p>
<p>同样的，可以为你自己的对象定义<code>Symbol.toStringTag</code>的值：</p>
<pre><code>function Person(name) {
    this.name = name;
}

Person.prototype[Symbol.toStringTag] = &quot;Person&quot;;
let me = new Person(&quot;heihei&quot;);

console.log(me.toString());                                //&quot;[object Person]&quot;
console.log(Object.prototype.toString.call(me));   //&quot;[object Person]&quot;
</code></pre>
<blockquote>
<p>除非另有说明，所以对象都会从 <code>Object.prototype</code> 挤成 <code>Symbol.toStringTag</code>这个属性，且默认的属性值为&quot;Object&quot;。</p>
</blockquote>
<p>对于开发者定义的对象来说，不限制<code>Symbol.toStringTag</code>属性的值的范围。例如，语言本身不会阻止你使用Array作为<code>Symbol.toStringTag</code>属性的值</p>
<pre><code>function Person(name){
    this.name = name;
}

Person.prototype[Symbol.toStringTag] = &quot;Array&quot;;

Person.prototype.toString = function() {
    return this.name;
}

let me = new Person(&quot;heihei&quot;);

console.log(me.toString());                              //&quot;heihei&quot;
console.log(Object.prototype.toString.call(me))  //&quot;[Object Array]&quot;
</code></pre>
<p>在这段代码中，调用Object.prototype.toString() 方法得到的结果是&quot;[object Array]&quot;，跟你从一个真实数组中得到的结果完全一样。这也就意味着，<code>Object.prototype.toString()</code>不是一个十分可靠的识别对象类型的方法。</p>
<br/>
<h3 id="symbolunscopables-属性">Symbol.unscopables 属性</h3>
<blockquote>
<p>with 语句是 JavaScript 中最有争议的一个语句，设计它的初衷是可以免于编写重复的代码。但由于加入with语句后，代码变得难以理解，它的执行性能很差且容易导致程序出错，因此被大多数开发者所诟病。最终，标准规定，在严格模式下不可以使用with语句；且这条限制同样影响到了类和模块，默认使用严格模式且没有任何退出的方法。</p>
</blockquote>
<pre><code>var values = [1,2,2],
     colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;],
     color = &quot;black&quot;;

with(colors) {
    push(color);
    push(...values);
}

console.log(colors);   //&quot;[&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;black&quot;, 1, 2, 2]&quot;
</code></pre>
<p>注意上面的代码里有个values变量，但在ECMAScript 6 中，数组中添加了一个values方法。总之，在ECMAScript6环境中，with语句引用的values不是with语句外的变量values,而是数组本身的values方法，这样就脱离代码原本的目标了。因此ECMAScript 6也添加了 <code>Symbol.unscopables</code>这个Symbol来解决这个问题。</p>
<p><code>Symbol.unscopables</code>这个Symbol通常用于<code>Array.prototype</code>。以在with语句中标示出不创建绑定的属性名。<code>Symbol.unscopables</code>是以对象的形式出现的，它的键是在with语句中要忽略的标识符，其对应的值必须是 true 。这里是数组<code>Symbol.unscopables</code>属性的默认值：</p>
<pre><code>// 已默认内置到ECMAScript 6中
Array.prototype[Symbol.unscopables] = Object.assign(Object.create(null),{
    copyWithin: true,
    entries: true,
    fill: true,
    find: true,
    findIndex: true,
    keys: true,
    values: true
})
</code></pre>
<p>☠️不要为自己创建的对象定义<code>Symbol.unscopables</code>属性，除非在代码中使用了with语句并且正在修改代码库中已有的对象。</p>
<h2 id="元编程">元编程💻</h2>
<h3 id="概述️">概述⌨️</h3>
<blockquote>
<p>元编程是指操作目标是程序本身的行为特性的编程。换句话说，它是对程序的编程的编程。（体会下上面的well-known api）</p>
</blockquote>
<br/>
<blockquote>
<p>内省：一种元编程形式，举例来说，如果想要查看对象a和另外一个对象b的关系是否是<code>[[prototype]]</code>链接🔗的，可以使用<code>a.isPrototype(b)</code>。</p>
</blockquote>
<p>元编程关注以下几点：</p>
<ul>
<li>代码查看自身</li>
<li>代码修改自身</li>
<li>代码修改默认语言特性</li>
</ul>
<p>元编程的目标是利用语言本身的内省能力使代码的其余本分更具描述性，表达性和灵活性</p>
<br/>
<h3 id="元属性">元属性🖥</h3>
<blockquote>
<p>元属性以属性访问的形式提供特殊的其他方法无法获取的元信息。</p>
</blockquote>
<p>以 new.target 为🌰，关键字new用作属性访问的上下文。显然，new 本身不是一个对象，因此这个功能很特殊。而在构造器调用（通过new触发的函数/方法）内部使用new.target时，new成了一个虚拟上下文，使得new.target能够指向调用new的目标构造器。</p>
<p>这个是元编程操作的一个明显示例，因为它的目的是从构造器调用内部确定最初new的目标是什么，通用地说用于内省（检查类型/结构）或者静态属性访问。</p>
<blockquote>
<p>好吧😨，这个整不来整不来，太吃力了。留个坑，以后回来再填。👻</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[wtfjs]]></title>
        <id>https://heihei12305.github.io/post/wtfjs/</id>
        <link href="https://heihei12305.github.io/post/wtfjs/">
        </link>
        <updated>2020-01-02T16:07:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>一个有趣和棘手的 JavaScript 示例列表。</p>
</blockquote>
<p>基于个人理解加 google 翻译，如有问题请指正，谢谢。(原文这样写的，本文只为方便自己阅读<a href="https://github.com/denysdovhan/wtfjs">github地址</a>)</p>
<p>JavaScript 是一种很好的语言。它有一个简单的语法，庞大的生态系统，以及最重要，最伟大的社区。</p>
<p>同时，我们都知道，JavaScript 是一个非常有趣的语言，具有棘手的部分。 他们中的一些可以迅速将我们的日常工作变成地狱，有些可以让我们大声笑起来。</p>
<p>WTFJS 的原创思想属于 <a href="https://twitter.com/brianleroux">Brian Leroux</a>. 这个列表受到他的讲话的高度启发 <a href="https://www.youtube.com/watch?v=et8xNAc2ic8"><strong>“WTFJS”</strong> at dotJS 2012</a>:</p>
<figure data-type="image" tabindex="1"><a href="https://www.youtube.com/watch?v=et8xNAc2ic8"><img src="https://img.youtube.com/vi/et8xNAc2ic8/0.jpg" alt="dotJS 2012 - Brian Leroux - WTFJS" loading="lazy"></a></figure>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<h1 id="目录">目录</h1>
<ul>
<li><a href="#-%E5%8A%A8%E6%9C%BA">💪🏻 动机</a></li>
<li><a href="#-%E7%AC%A6%E5%8F%B7">✍🏻 符号</a></li>
<li><a href="#-%E4%BE%8B%E5%AD%90">👀 例子</a>
<ul>
<li><a href="#-%E7%AD%89%E4%BA%8E-"><code>[]</code> 等于 <code>![]</code></a></li>
<li><a href="#true-%E6%98%AF-false">true is false</a></li>
<li><a href="#baNaNa">baNaNa</a></li>
<li><a href="#nan-%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA-nan"><code>NaN</code> 不是一个 <code>NaN</code></a></li>
<li><a href="#%E5%AE%83%E6%98%AFfail">It's a fail</a></li>
<li><a href="#-%E6%98%AF-true-%E4%BD%86%E5%AE%83%E4%B8%8D%E7%AD%89%E4%BA%8E-true"><code>[]</code> 本身是 true, 但又不等于 <code>true</code></a></li>
<li><a href="#null-%E6%98%AFfalse-%E4%BD%86%E5%8F%88%E4%B8%8D%E7%AD%89%E4%BA%8E-false"><code>null</code> 本身是 false, 但又不等于 <code>false</code></a></li>
<li><a href="#%E6%9C%80%E5%B0%8F%E5%80%BC%E5%A4%A7%E4%BA%8E%E9%9B%B6">最小值大于零</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%8F%88%E4%B8%8D%E6%98%AF%E5%87%BD%E6%95%B0">函数又不是函数</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E7%9B%B8%E5%8A%A0">数组相加</a></li>
<li><a href="#undefined-%E5%92%8C-number"><code>undefined</code> 和 <code>Number</code></a></li>
<li><a href="#parseint-%E6%98%AF%E4%B8%80%E4%B8%AA%E5%9D%8F%E8%9B%8B"><code>parseInt</code> 是一个坏蛋 </a></li>
<li><a href="#true-%E5%92%8C-false-%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97">数学计算中 <code>true</code> 和 <code>false</code></a></li>
<li><a href="#html%E6%B3%A8%E9%87%8A%E5%9C%A8javascript%E4%B8%AD%E6%9C%89%E6%95%88">HTML 注释在 JavaScript 中有效</a></li>
<li><a href="#nan-%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E6%95%B0%E5%80%BC"><code>NaN</code> <s>不是</s> 一个数值</a></li>
<li><a href="#-%E5%92%8C-null-%E6%98%AF%E5%AF%B9%E8%B1%A1"><code>[]</code> 和 <code>null</code> 都是对戏那个</a></li>
<li><a href="#%E7%A5%9E%E5%A5%87%E5%A4%9A%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97">神奇的数字</a></li>
<li><a href="#01--02-%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97">精度问题 <code>0.1 + 0.2</code></a></li>
<li><a href="#%E6%89%A9%E5%B1%95%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%B9%E6%B3%95">修复数字</a></li>
<li><a href="#%E4%B8%89%E4%B8%AA%E6%95%B0%E5%AD%97%E7%9A%84%E6%AF%94%E8%BE%83">三个数字的比较</a></li>
<li><a href="#%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%AD%A6">有趣的数学</a></li>
<li><a href="#%E6%89%A9%E5%B1%95%E6%AD%A3%E5%88%99">添加正则表达式</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8D%E6%98%AF-string-%E7%9A%84%E5%AE%9E%E4%BE%8B">字符串不是 <code>String</code> 的实例</a></li>
<li><a href="#%E7%94%A8%E5%8F%8D%E5%BC%95%E5%8F%B7%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0">用反引号调用函数</a></li>
<li><a href="#%E8%B0%83%E7%94%A8-%E8%B0%83%E7%94%A8-%E8%B0%83%E7%94%A8">调用 调用 调用</a></li>
<li><a href="#%E4%B8%80%E4%B8%AAconstructor%E5%B1%9E%E6%80%A7">一个 <code>constructor</code> 属性</a></li>
<li><a href="#%E5%B0%86%E5%AF%B9%E8%B1%A1%E5%81%9A%E4%B8%BA%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84key">将对象做为另一个对象的 key</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE%E5%8E%9F%E5%9E%8B-__proto__">用<code>__proto__</code>访问原型</a></li>
<li><a href="#-object-"><code>`${{Object}}`</code></a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E5%80%BC%E8%BF%9B%E8%A1%8C%E7%BB%93%E6%9E%84%E5%8C%96">使用默认值进行结构化</a></li>
<li><a href="#%E7%82%B9-%E5%92%8C-%E8%A7%A3%E6%9E%84">点 和 解构</a></li>
<li><a href="#%E6%A0%87%E7%AD%BE">标签</a></li>
<li><a href="#%E5%B5%8C%E5%A5%97%E6%A0%87%E7%AD%BE">嵌套标签</a></li>
<li><a href="#%E9%98%B4%E9%99%A9%E7%9A%84-trycatch">阴险的 <code>try..catch</code></a></li>
<li><a href="#%E8%BF%99%E6%98%AF%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%90%97">这是多重继承吗？</a></li>
<li><a href="#a-generator-which-yields-itself">A generator which yields itself</a></li>
<li><a href="#%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E7%B1%BB">一个类的类</a></li>
<li><a href="#%E9%9D%9E%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%AF%B9%E8%B1%A1">非强制转换对象</a></li>
<li><a href="#%E6%A3%98%E6%89%8B%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%8A%9F%E8%83%BD">棘手的箭头功能</a></li>
<li><a href="#arguments-%E5%92%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><code>arguments</code>和箭头函数</a></li>
<li><a href="#%E6%A3%98%E6%89%8B%E7%9A%84%E8%BF%94%E5%9B%9E">棘手的返回</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">使用数组访问对象属性</a></li>
<li><a href="#%E7%A9%BA%E5%92%8C%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6">Null 和关系操作符</a></li>
<li><a href="#numbertofixed-%E6%98%BE%E7%A4%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E5%AD%97"><code>Number.toFixed()</code> 显示不同的数字</a></li>
<li><a href="#%E6%AF%94%E8%BE%83-null-to-0">比较 <code>null</code> to <code>0</code></a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90">其他资源</a></li>
<li><a href="#-license">🎓 License</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="动机">💪🏻 动机</h1>
<blockquote>
<p>只是为了好玩 （tips：我翻译这篇文章同样也是为了好玩）</p>
<p>— <em><a href="https://en.m.wikipedia.org/wiki/Just_for_Fun"><strong>“只是为了好玩：一个意外革命的故事”</strong></a>, 托瓦兹</em></p>
</blockquote>
<p>这个列表的主要目的是收集一些疯狂的例子，并解释它们如何工作，如果可能的话。 只是因为学习以前不了解的东西很有趣。</p>
<p>如果您是初学者，您可以使用此笔记来深入了解 JavaScript。 我希望这个笔记会激励你花更多的时间阅读规范。</p>
<p>如果您是专业开发人员，您可以将这些示例视为您公司新手访问问题和测验的重要资源。 同时，这些例子在准备面试时会很方便。</p>
<p>无论如何，只是读这个。 也许你会为自己找到新的东西。</p>
<h1 id="符号">✍🏻 符号</h1>
<p><strong><code>// -&gt;</code></strong> 用于显示表达式的结果。 例如：</p>
<pre><code class="language-js">1 + 1; // -&gt; 2
</code></pre>
<p><strong><code>// &gt;</code></strong> 意思是 <code>console.log</code> 或其他输出的结果。 例如：</p>
<pre><code class="language-js">console.log(&quot;hello, world!&quot;); // &gt; hello, world!
</code></pre>
<p><strong><code>//</code></strong> 只是一个解释的评论。 例：</p>
<pre><code class="language-js">// Assigning a function to foo constant
const foo = function() {};
</code></pre>
<h1 id="例子">👀 例子</h1>
<h2 id="等于"><code>[]</code> 等于 <code>![]</code></h2>
<p>数组等于一个数组取反</p>
<pre><code class="language-js">[] == ![]; // -&gt; true
</code></pre>
<h3 id="说明">💡 说明:</h3>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-logical-not-operator"><strong>12.5.9</strong> 逻辑非运算符 (<code>!</code>)</a></li>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison"><strong>7.2.13</strong> 抽象相等比较 </a></li>
</ul>
<h2 id="true-是-false">true 是 false</h2>
<pre><code class="language-js">!!&quot;false&quot; == !!&quot;true&quot;; // -&gt; true
!!&quot;false&quot; === !!&quot;true&quot;; // -&gt; true
</code></pre>
<h3 id="说明-2">💡 说明:</h3>
<p>考虑一下这一步：</p>
<pre><code class="language-js">true == &quot;true&quot;; // -&gt; true
false == &quot;false&quot;; // -&gt; false

// 'false' 不是空字符串，所以它的值是true
!!&quot;false&quot;; // -&gt; true
!!&quot;true&quot;; // -&gt; true
</code></pre>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison"><strong>7.2.13</strong> 抽象相等比较 </a></li>
</ul>
<h2 id="banana">baNaNa</h2>
<pre><code class="language-js">&quot;b&quot; + &quot;a&quot; + +&quot;a&quot; + &quot;a&quot;;
</code></pre>
<p>用 JavaScript 写的老派笑话：</p>
<pre><code class="language-js">&quot;foo&quot; + +&quot;bar&quot;; // -&gt; 'fooNaN'
</code></pre>
<h3 id="说明-3">💡 说明:</h3>
<p>这个表达式可以转化成 <code>'foo' + (+'bar')</code>，但无法将<code>'bar'</code>强制转化成数值</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-addition-operator-plus"><strong>12.8.3</strong> 加法运算符 (<code>+</code>)</a></li>
</ul>
<h2 id="nan-不是一个-nan"><code>NaN</code> 不是一个 <code>NaN</code></h2>
<pre><code class="language-js">NaN === NaN; // -&gt; false
</code></pre>
<h3 id="说明-4">💡 说明:</h3>
<p>规范严格定义了这种行为背后的逻辑：</p>
<blockquote>
<ol>
<li>如果 <code>Type(x)</code> 不同于 <code>Type(y)</code>, return <strong>false</strong>.</li>
<li>如果 <code>Type(x)</code> 数值, 然后
<ol>
<li>如果 <code>x</code> 是 <strong>NaN</strong>, return <strong>false</strong>.</li>
<li>如果 <code>y</code> 是 <strong>NaN</strong>, return <strong>false</strong>.</li>
<li>… … …</li>
</ol>
</li>
</ol>
<p>— <a href="https://www.ecma-international.org/ecma-262/#sec-strict-equality-comparison"><strong>7.2.14</strong> 严格模式相等比较 </a></p>
</blockquote>
<p>遵循 IEEE 的“NaN”的定义：</p>
<blockquote>
<p>四个相互排斥的关系是可能的：小于，等于，大于和无序。 当至少一个操作数是 NaN 时，最后一种情况出现。 每个 NaN 都要比较无穷无尽的一切，包括自己。</p>
<p>— <a href="https://stackoverflow.com/questions/1565164/1573715#1573715">“对于 IEEE754 NaN 值的所有比较返回 false 的理由是什么？”</a> at StackOverflow</p>
</blockquote>
<h2 id="它是-fail">它是 fail</h2>
<p>你不会相信，但...</p>
<pre><code class="language-js">(![] + [])[+[]] +
  (![] + [])[+!+[]] +
  ([![]] + [][[]])[+!+[] + [+[]]] +
  (![] + [])[!+[] + !+[]];
// -&gt; 'fail'
</code></pre>
<h3 id="说明-5">💡 说明:</h3>
<p>将大量的符号分解成片段，我们注意到，以下表达式经常发生：</p>
<pre><code class="language-js">![] + []; // -&gt; 'false'
![]; // -&gt; false
</code></pre>
<p>所以我们尝试将<code>[]</code>和<code>false</code>加起来。 但是通过一些内部函数调用（<code>binary + Operator</code> - &gt;<code>ToPrimitive</code> - &gt;<code>[[DefaultValue]</code> ]），我们最终将右边的操作数转换为一个字符串：</p>
<pre><code class="language-js">![] + [].toString(); // 'false'
</code></pre>
<p>将字符串作为数组，我们可以通过<code>[0]</code>来访问它的第一个字符：</p>
<pre><code class="language-js">&quot;false&quot;[0]; // -&gt; 'f'
</code></pre>
<p>现在，其余的是明显的，可以自己弄清楚！</p>
<h2 id="是-true-但它不等于-true"><code>[]</code> 是 <code>true</code>, 但它不等于 <code>true</code></h2>
<p>数组是一个<code>true</code>，但是它不等于<code>true</code>。</p>
<pre><code class="language-js">!![]       // -&gt; true
[] == true // -&gt; false
</code></pre>
<h3 id="说明-6">💡 说明:</h3>
<p>以下是 ECMA-262 规范中相应部分的链接：</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-logical-not-operator"><strong>12.5.9</strong> 逻辑非运算符 (<code>!</code>)</a></li>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison"><strong>7.2.13</strong> 抽象相等比较 </a></li>
</ul>
<h2 id="null-是-false-但又不等于-false"><code>null</code> 是 false, 但又不等于 <code>false</code></h2>
<p>尽管 <code>null</code> 是 <code>false</code> ，但它不等于 <code>false</code>。</p>
<pre><code class="language-js">!!null; // -&gt; false
null == false; // -&gt; false
</code></pre>
<p>同时，其他的一些等于 false 的值，如 <code>0</code> 或 <code>''</code> 等于 <code>false</code> 。</p>
<pre><code class="language-js">0 == false; // -&gt; true
&quot;&quot; == false; // -&gt; true
</code></pre>
<h3 id="说明-7">💡 说明:</h3>
<p>跟前面的例子相同。 这是一个相应的链接：</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison"><strong>7.2.13</strong> 抽象相等比较 </a></li>
</ul>
<h2 id="最小值大于零">最小值大于零</h2>
<p><code>Number.MIN_VALUE</code> 是最小的数字，大于零：</p>
<pre><code class="language-js">Number.MIN_VALUE &gt; 0; // -&gt; true
</code></pre>
<h3 id="说明-8">💡 说明:</h3>
<blockquote>
<p><code>Number.MIN_VALUE</code> 是 <code>5e-324</code> ，即可以在浮点精度内表示的最小正数，即可以达到零。 它定义了最好的分辨率浮标给你。</p>
</blockquote>
<blockquote>
<p>现在，整体最小的值是 <code>Number.NEGATIVE_INFINITY</code> ，尽管这在严格意义上并不是真正的数字。</p>
<p>— <a href="https://stackoverflow.com/questions/26614728/why-is-0-less-than-number-min-value-in-javascript">“为什么在 JavaScript 中<code>0</code>小于<code>Number.MIN_VALUE</code>？”</a> at StackOverflow</p>
</blockquote>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-well-known-symbols"><strong>20.1.2.9</strong> Number.MIN_VALUE</a></li>
</ul>
<h2 id="函数不是函数">函数不是函数</h2>
<blockquote>
<p>⚠️ V8 v5.5 或更低版本中出现的 Bug（Node.js &lt;= 7） ⚠️</p>
</blockquote>
<p>所有你知道的关于噪声 <em>undefined 不是 function</em> 。是关于这个吗？</p>
<pre><code class="language-js">// Declare a class which extends null
class Foo extends null {}
// -&gt; [Function: Foo]

new Foo() instanceof null;
// &gt; TypeError: function is not a function
// &gt;     at … … …
</code></pre>
<h3 id="说明-9">💡 说明:</h3>
<p>这不是规范的一部分。这只是一个错误，现在它已被修复，所以将来不会有这个问题。</p>
<h2 id="数组相加">数组相加</h2>
<p>如果您尝试两个数组相加呢？</p>
<pre><code class="language-js">[1, 2, 3] + [4, 5, 6]; // -&gt; '1,2,34,5,6'
</code></pre>
<h3 id="说明-10">💡 说明:</h3>
<p>会发生合并。一步一步地，它是这样的:</p>
<pre><code class="language-js">[1, 2, 3] +
  [4, 5, 6][
    // joining
    (1, 2, 3)
  ].join() +
  [4, 5, 6].join();
// concatenation
&quot;1,2,3&quot; + &quot;4,5,6&quot;;
// -&gt;
(&quot;1,2,34,5,6&quot;);
</code></pre>
<h1 id="数组中的逗号">数组中的逗号</h1>
<p>您已经创建了一个包含 4 个空元素的数组。尽管如此，你还是会得到一个有三个元素的，因为后面的逗号:</p>
<pre><code class="language-js">let a = [, , ,];
a.length; // -&gt; 3
a.toString(); // -&gt; ',,'
</code></pre>
<h3 id="说明-11">💡 说明:</h3>
<blockquote>
<p><strong>尾逗号</strong> (有时也称为“最后逗号”) 在向 JavaScript 代码中添加新元素、参数或属性时有用。如果您想添加一个新属性，您可以简单地添加一个新行，而不用修改以前的最后一行，如果该行已经使用了后面的逗号。这使得版本控制比较清洁和编辑代码可能不太麻烦。</p>
<p>— <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Trailing_commas">Trailing commas</a> at MDN</p>
</blockquote>
<h2 id="数组相等是一个怪物">数组相等是一个怪物</h2>
<p>数组进行相等比较是一个怪物，看下面的例子：</p>
<pre><code class="language-js">[] == ''   // -&gt; true
[] == 0    // -&gt; true
[''] == '' // -&gt; true
[0] == 0   // -&gt; true
[0] == ''  // -&gt; false
[''] == 0  // -&gt; true

[null] == ''      // true
[null] == 0       // true
[undefined] == '' // true
[undefined] == 0  // true

[[]] == 0  // true
[[]] == '' // true

[[[[[[]]]]]] == '' // true
[[[[[[]]]]]] == 0  // true

[[[[[[ null ]]]]]] == 0  // true
[[[[[[ null ]]]]]] == '' // true

[[[[[[ undefined ]]]]]] == 0  // true
[[[[[[ undefined ]]]]]] == '' // true
</code></pre>
<h3 id="说明-12">💡 说明:</h3>
<p>你应该非常小心，因为上面！这是一个复杂的例子，但它的描述 <a href="https://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison"><strong>7.2.13</strong> Abstract Equality Comparison</a> 规范部分。</p>
<h2 id="undefined-和-number"><code>undefined</code> 和 <code>Number</code></h2>
<p>如果我们不把任何参数传递到 <code>Number</code> 构造函数中，我们将得到 <code>0</code> 。<code>undefined</code> 是一个赋值形参，没有实际的参数，所以您可能期望 <code>NaN</code> 将 <code>undefined</code> 作为参数的值。然而，当我们通过 <code>undefined</code> ，我们将得到 <code>NaN</code> 。</p>
<pre><code class="language-js">Number(); // -&gt; 0
Number(undefined); // -&gt; NaN
</code></pre>
<h3 id="说明-13">💡 说明:</h3>
<p>根据规范：</p>
<ol>
<li>如果没有参数传递给这个函数，让 <code>n</code> 为 <code>+0</code> ;</li>
<li>否则，让 <code>n</code> 调用 <code>ToNumber(value)</code></li>
<li>如果值为 <code>undefined</code>,那么 <code>ToNumber(undefined)</code> 应该返回 <code>NaN</code>.</li>
</ol>
<p>这是相应的部分：</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-number-constructor"><strong>20.1.1</strong> Number 构造器函数 </a></li>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-tonumber"><strong>7.1.3</strong> ToNumber(<code>argument</code>)</a></li>
</ul>
<h2 id="parseint-是一个坏蛋"><code>parseInt</code> 是一个坏蛋</h2>
<p><code>parseInt</code> 它以的怪异而出名。</p>
<pre><code class="language-js">parseInt(&quot;f*ck&quot;); // -&gt; NaN
parseInt(&quot;f*ck&quot;, 16); // -&gt; 15
</code></pre>
<p>**💡 说明:</p>
<p>** 这是因为 <code>parseInt</code> 会继续通过解析直到它解析到一个不识别的字符，<code>f</code> 在 <code>'fuck'</code> 是 <code>15进制</code></p>
<p>解析 <code>Infinity</code> 到整数是什么…</p>
<pre><code class="language-js">//
parseInt(&quot;Infinity&quot;, 10); // -&gt; NaN
// ...
parseInt(&quot;Infinity&quot;, 18); // -&gt; NaN...
parseInt(&quot;Infinity&quot;, 19); // -&gt; 18
// ...
parseInt(&quot;Infinity&quot;, 23); // -&gt; 18...
parseInt(&quot;Infinity&quot;, 24); // -&gt; 151176378
// ...
parseInt(&quot;Infinity&quot;, 29); // -&gt; 385849803
parseInt(&quot;Infinity&quot;, 30); // -&gt; 13693557269
// ...
parseInt(&quot;Infinity&quot;, 34); // -&gt; 28872273981
parseInt(&quot;Infinity&quot;, 35); // -&gt; 1201203301724
parseInt(&quot;Infinity&quot;, 36); // -&gt; 1461559270678...
parseInt(&quot;Infinity&quot;, 37); // -&gt; NaN
</code></pre>
<p>小心解析 <code>null</code> ：</p>
<pre><code class="language-js">parseInt(null, 24); // -&gt; 23
</code></pre>
<p><strong>💡 说明:</strong></p>
<blockquote>
<p>它将 <code>null</code> 转换成字符串 <code>'null'</code> ，并尝试转换它。 对于基数 0 到 23，没有可以转换的数字，因此返回 NaN。 在 24，<code>“n”</code> ，第 14 个字母被添加到数字系统。 在 31，<code>“u”</code> ，添加第 21 个字母，可以解码整个字符串。 在 37 处，不再有可以生成的有效数字集，并返回 <code>NaN</code> 。</p>
<p>— <a href="https://stackoverflow.com/questions/6459758/parseintnull-24-23-wait-what">“parseInt(null, 24) === 23… wait, what?”</a> at StackOverflow</p>
</blockquote>
<p>不要忘记八进制：</p>
<pre><code class="language-js">parseInt(&quot;06&quot;); // 6
parseInt(&quot;08&quot;); // 0
</code></pre>
<p><strong>💡 说明:</strong></p>
<p>这是因为 <code>parseInt</code> 能够接受两个参数，如果没有提供第二个参数，并且第一个参数以 <code>0</code> 开始，它将被解析为八进制数。</p>
<h2 id="true-和-false-数学运算"><code>true</code> 和 <code>false</code> 数学运算</h2>
<p>我们做一些数学计算：</p>
<pre><code class="language-js">true +
  true(
    // -&gt; 2
    true + true
  ) *
    (true + true) -
  true; // -&gt; 3
</code></pre>
<p>嗯… 🤔</p>
<h3 id="说明-14">💡 说明:</h3>
<p>我们可以用 <code>Number</code> 构造函数强制转化成数值。 很明显，<code>true</code> 将被强制转换为 <code>1</code> ：</p>
<pre><code class="language-js">Number(true); // -&gt; 1
</code></pre>
<p>一元加运算符尝试将其值转换成数字。 它可以转换整数和浮点的字符串表示，以及非字符串值 <code>true</code> ，<code>false</code> 和 <code>null</code> 。 如果它不能解析特定的值，它将转化为 <code>NaN</code> 。 这意味着我们可以更容易地强制将 <code>true</code> 换成 <code>1</code></p>
<pre><code class="language-js">+true; // -&gt; 1
</code></pre>
<p>当你执行加法或乘法时，<code>ToNumber</code>方法调用。 根据规范，该方法返回：</p>
<blockquote>
<p>如果 <code>参数</code> is <strong>true</strong> , 返回 <strong>1</strong> 。 如果 <code>参数</code> 是 <strong>false</strong> 返回 <strong>+0</strong>。</p>
</blockquote>
<p>这就是为什么我们可以进行进行布尔值相加并得到正确的结果</p>
<p>相应部分：</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-unary-plus-operator"><strong>12.5.6</strong> 一元 <code>+</code> 运算符 </a></li>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-addition-operator-plus"><strong>12.8.3</strong> 加法运算符（<code>+</code>） </a></li>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-tonumber"><strong>7.1.3</strong> ToNumber(<code>argument</code>)</a></li>
</ul>
<h2 id="html-注释在-javascript-中有效">HTML 注释在 JavaScript 中有效</h2>
<p>你会留下深刻的印象， <code>&lt;!--</code> (这被称为 HTML 注释）是一个有效的 JavaScript 注释。</p>
<pre><code class="language-js">// valid comment
&lt;!-- valid comment too
</code></pre>
<h3 id="说明-15">💡 说明:</h3>
<p>深刻的印象吗? html 类似的注释旨在允许不理解标签的浏览器优雅地降级。这些浏览器，例如 Netscape 1。x 不再受欢迎。因此，在脚本标记中添加 HTML 注释是没有意义的。</p>
<p>由于 Node.js 基于 V8 引擎，Node.js 运行时也支持类似 HTML 的注释。 而且，它们是规范的一部分：</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-html-like-comments"><strong>B.1.3</strong> 类似 HTML 的注释 </a></li>
</ul>
<h2 id="nan-不是一个数值"><code>NaN</code> 不是一个数值</h2>
<p>尽管 <code>NaN</code> 类型是 <code>'number'</code> ，但是 <code>NaN</code> 不是数字的实例：</p>
<pre><code class="language-js">typeof NaN; // -&gt; 'number'
NaN instanceof Number; // -&gt; false
</code></pre>
<h3 id="说明-16">💡 说明:</h3>
<p><code>typeof</code> 和 <code>instanceof</code> 运算符的工作原理：</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-typeof-operator"><strong>12.5.5</strong> <code>typeof</code> 操作符</a></li>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-instanceofoperator"><strong>12.10.4</strong> Runtime Semantics: InstanceofOperator(<code>O</code>,<code>C</code>)</a></li>
</ul>
<h2 id="和-null-是对象"><code>[]</code> 和 <code>null</code> 是对象</h2>
<pre><code class="language-js">typeof []; // -&gt; 'object'
typeof null; // -&gt; 'object'

// 然而
null instanceof Object; // false
</code></pre>
<h3 id="说明-17">💡 说明:</h3>
<p><code>typeof</code> 运算符的行为在本节的规范中定义：</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-typeof-operator"><strong>12.5.5</strong> <code>typeof</code> 操作符 </a></li>
</ul>
<p>根据规范，<code>typeof</code> 操作符返回一个字符串 <a href="https://www.ecma-international.org/ecma-262/#table-35">Table 35: <code>typeof</code> Operator Results</a>. 对于 <code>null</code> ，普通的，标准的异常和非标准的异常对象，它不实现 <code>[[Call]]</code> 它返回字符串 <code>&quot;对象“</code> 。</p>
<p>但是，您可以使用 <code>toString</code> 方法检查对象的类型。</p>
<pre><code class="language-js">Object.prototype.toString.call([]);
// -&gt; '[object Array]'

Object.prototype.toString.call(new Date());
// -&gt; '[object Date]'

Object.prototype.toString.call(null);
// -&gt; '[object Null]'
</code></pre>
<h2 id="神奇多位的数字">神奇多位的数字</h2>
<pre><code class="language-js">999999999999999; // -&gt; 999999999999999
9999999999999999; // -&gt; 10000000000000000
</code></pre>
<h3 id="说明-18">💡 说明:</h3>
<p>这是由 IEEE 754-2008 二进制浮点运算标准引起的。 阅读更多：</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-ecmascript-language-types-number-type"><strong>6.1.6</strong> The Number Type</a></li>
<li><a href="https://en.m.wikipedia.org/wiki/IEEE_754">IEEE 754</a> on Wikipedia</li>
</ul>
<h2 id="01-02-精度计算"><code>0.1 + 0.2</code> 精度计算</h2>
<p>来自 JavaScript 的知名笑话 <code>0.1</code> 和 <code>0.2</code> 相加是存在精度错误的</p>
<pre><code class="language-js">0.1 + 0.2; // -&gt; 0.30000000000000004
</code></pre>
<h3 id="说明-19">💡 说明:</h3>
<p>答案为 <a href="https://stackoverflow.com/questions/588004/is-floating-point-math-broken">”浮点数学是坏的？”</a> 问题在 StackOverflow:</p>
<blockquote>
<p>程序中的常量 <code>0.2</code> 和 <code>0.3</code> 也将近似为真值。 发生最接近的 <code>double</code> 到 <code>0.2</code> 大于有理数 <code>0.2</code> ，但最接近的 <code>double</code> 到 <code>0.3</code> 小于有理数 <code>0.3</code> 。 <code>0.1</code> 和 <code>0.2</code> 的总和大于理性数 <code>0.3</code> ，因此不符合您的代码中的常数。</p>
</blockquote>
<p>这个问题是众所周知的，甚至有一个网站叫 <a href="http://0.30000000000000004.com/">0.30000000000000004.com</a>.</p>
<h2 id="扩展数字的方法">扩展数字的方法</h2>
<p>您可以添加自己的方法来包装对象，如 <code>Number</code> 或 <code>String</code> 。</p>
<pre><code class="language-js">Number.prototype.isOne = function() {
  return Number(this) === 1;
};

(1.0).isOne(); // -&gt; true
(1).isOne(); // -&gt; true
(2.0)
  .isOne()(
    // -&gt; false
    7
  )
  .isOne(); // -&gt; false
</code></pre>
<h3 id="说明-20">💡 说明:</h3>
<p>显然，您可以像 JavaScript 中的任何其他对象一样扩展 <code>Number</code> 对象。 但是，如果定义的方法的行为不是规范的一部分，则不建议。 以下是 <code>Number</code> 属性的列表：</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-number-objects"><strong>20.1</strong> Number Objects</a></li>
</ul>
<h2 id="三个数字的比较">三个数字的比较</h2>
<pre><code class="language-js">1 &lt; 2 &lt; 3; // -&gt; true
3 &gt; 2 &gt; 1; // -&gt; false
</code></pre>
<h3 id="说明-21">💡 说明:</h3>
<p>为什么这样做呢？ 那么问题在于表达式的第一部分。 以下是它的工作原理：</p>
<pre><code class="language-js">1 &lt; 2 &lt; 3; // 1 &lt; 2 -&gt; true
true &lt; 3; // true -&gt; 1
1 &lt; 3; // -&gt; true

3 &gt; 2 &gt; 1; // 3 &gt; 2 -&gt; true
true &gt; 1; // true -&gt; 1
1 &gt; 1; // -&gt; false
</code></pre>
<p>我们可以用大于或等于运算符（<code>&gt; =</code>）</p>
<pre><code class="language-js">3 &gt; 2 &gt;= 1; // true
</code></pre>
<p>详细了解规范中的关系运算符：</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-relational-operators"><strong>12.10</strong> Relational Operators</a></li>
</ul>
<h2 id="有趣的数学">有趣的数学</h2>
<p>通常 JavaScript 中的算术运算的结果可能是非常难以预料的。 考虑这些例子：</p>
<pre><code class="language-js"> 3  - 1  // -&gt; 2
 3  + 1  // -&gt; 4
'3' - 1  // -&gt; 2
'3' + 1  // -&gt; '31'

'' + '' // -&gt; ''
[] + [] // -&gt; ''
{} + [] // -&gt; 0
[] + {} // -&gt; '[object Object]'
{} + {} // -&gt; '[object Object][object Object]'

'222' - -'111' // -&gt; 333

[4] * [4]       // -&gt; 16
[] * []         // -&gt; 0
[4, 4] * [4, 4] // NaN
</code></pre>
<h3 id="说明-22">💡 说明:</h3>
<p>前四个例子发生了什么？ 这是一个小表，以了解 JavaScript 中的添加：</p>
<pre><code>Number  + Number  -&gt; addition
Boolean + Number  -&gt; addition
Boolean + Boolean -&gt; addition
Number  + String  -&gt; concatenation
String  + Boolean -&gt; concatenation
String  + String  -&gt; concatenation
</code></pre>
<p>剩下的例子呢？ 在相加之前，<code>[]</code> 和 <code>{}</code> 隐含地调用 <code>ToPrimitive</code> 和 <code>ToString</code> 方法。 详细了解规范中的评估过程：</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-addition-operator-plus"><strong>12.8.3</strong> The Addition Operator (<code>+</code>)</a></li>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-toprimitive"><strong>7.1.1</strong> ToPrimitive(<code>input</code> [,<code>PreferredType</code>])</a></li>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-tostring"><strong>7.1.12</strong> ToString(<code>argument</code>)</a></li>
</ul>
<h2 id="扩展正则">扩展正则</h2>
<p>你知道可以做这样的运算吗？</p>
<pre><code class="language-js">// Patch a toString method
RegExp.prototype.toString =
  function() {
    return this.source;
  } /
  7 /
  -/5/; // -&gt; 2
</code></pre>
<h3 id="说明-23">💡 说明:</h3>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-get-regexp.prototype.source"><strong>21.2.5.10</strong> get RegExp.prototype.source</a></li>
</ul>
<h2 id="字符串不是-string-的实例">字符串不是 <code>String</code> 的实例</h2>
<pre><code class="language-js">&quot;str&quot;; // -&gt; 'str'
typeof &quot;str&quot;; // -&gt; 'string'
&quot;str&quot; instanceof String; // -&gt; false
</code></pre>
<h3 id="说明-24">💡 说明:</h3>
<p><code>String</code> 构造函数返回一个字符串：</p>
<pre><code class="language-js">typeof String(&quot;str&quot;); // -&gt; 'string'
String(&quot;str&quot;); // -&gt; 'str'
String(&quot;str&quot;) == &quot;str&quot;; // -&gt; true
</code></pre>
<p>我们来试试一个 <code>new</code> ：</p>
<pre><code class="language-js">new String(&quot;str&quot;) == &quot;str&quot;; // -&gt; true
typeof new String(&quot;str&quot;); // -&gt; 'object'
</code></pre>
<p>对象?那是什么?</p>
<pre><code class="language-js">new String(&quot;str&quot;); // -&gt; [String: 'str']
</code></pre>
<p>有关规范中的 String 构造函数的更多信息：</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-string-constructor"><strong>21.1.1</strong> The String Constructor</a></li>
</ul>
<h2 id="用反引号调用函数">用反引号调用函数</h2>
<p>我们来声明一个返回所有参数到控制台中的函数：</p>
<pre><code class="language-js">function f(...args) {
  return args;
}
</code></pre>
<p>毫无疑问，你知道你可以这样调用这个函数：</p>
<pre><code class="language-js">f(1, 2, 3); // -&gt; [ 1, 2, 3 ]
</code></pre>
<p>但是你知道你可以使用反引号来调用任何函数吗？</p>
<pre><code class="language-js">f`true is ${true}, false is ${false}, array is ${[1, 2, 3]}`;
// -&gt; [ [ 'true is ', ', false is ', ', array is ', '' ],
// -&gt;   true,
// -&gt;   false,
// -&gt;   [ 1, 2, 3 ] ]
</code></pre>
<h3 id="说明-25">💡 说明:</h3>
<p>那么，如果你熟悉 <em>Tagged 模板文字</em> ，这根本就不是魔术。 在上面的例子中，<code>f</code> 函数是模板文字的标签。 模板文字之前的标签允许您使用函数解析模板文字。 标签函数的第一个参数包含字符串值的数组。 其余的参数与表达式有关。 例：</p>
<pre><code class="language-js">function template(strings, ...keys) {
  // 用字符串和键做一些事情
}
</code></pre>
<p>这是<a href="https://www.styled-components.com/">💅 styled-components</a>这个React社区很流行的库<a href="http://mxstbr.blog/2016/11/styled-components-magic-explained/">背后的秘密</a>。</p>
<p>规范的链接：</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-tagged-templates"><strong>12.3.7</strong> Tagged Templates</a></li>
</ul>
<h2 id="调用-调用-调用">调用 调用 调用</h2>
<blockquote>
<p>发现于 <a href="http://twitter.com/cramforce">@cramforce</a></p>
</blockquote>
<pre><code class="language-js">console.log.call.call.call.call.call.apply(a =&gt; a, [1, 2]);
</code></pre>
<h3 id="说明-26">💡 说明:</h3>
<p>注意，可能会打破你的头脑！ 尝试在您的头脑中重现此代码：我们使用<code>apply</code>方法应用<code>call</code>方法。 阅读更多：</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-function.prototype.call"><strong>19.2.3.3</strong> Function.prototype.call(<code>thisArg</code>, ...<code>args</code>)</a></li>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-function.prototype.apply">**19.2.3.1 ** Function.prototype.apply(<code>thisArg</code>, <code>argArray</code>)</a></li>
</ul>
<h2 id="一个constructor属性">一个<code>constructor</code>属性</h2>
<pre><code class="language-js">const c = &quot;constructor&quot;;
c[c][c]('console.log(&quot;WTF?&quot;)')(); // &gt; WTF?
</code></pre>
<h3 id="说明-27">💡 说明:</h3>
<p>让我们逐步考虑一下这个例子：</p>
<pre><code class="language-js">// Declare a new constant which is a string 'constructor'
const c = &quot;constructor&quot;;

// c 是一个字符串
c; // -&gt; 'constructor'

// 获取字符串的构造函数
c[c]; // -&gt; [Function: String]

// 获取构造函数的构造函数
c[c][c]; // -&gt; [Function: Function]

// 调用函数构造函数并将新函数的主体作为参数传递
c[c][c]('console.log(&quot;WTF?&quot;)'); // -&gt; [Function: anonymous]

// 然后调用这个匿名函数得到的结果是一个字符串'WTF'
c[c][c]('console.log(&quot;WTF?&quot;)')(); // &gt; WTF
</code></pre>
<p>一个 <code>Object.prototype.constructor</code> 返回一个引用对象的构造函数创建的实例对象。 在字符串的情况下，它是 <code>String</code> ，在数字的情况下它是 <code>数字</code> 等等。</p>
<ul>
<li><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor"><code>Object.prototype.constructor</code></a> at MDN</li>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-object.prototype.constructor"><strong>19.1.3.1</strong> Object.prototype.constructor</a></li>
</ul>
<h2 id="将对象做为另一个对象的-key">将对象做为另一个对象的 key</h2>
<pre><code class="language-js">{ [{}]: {} } // -&gt; { '[object Object]': {} }
</code></pre>
<h3 id="说明-28">💡 说明:</h3>
<p>为什么这样工作？ 这里我们使用 <em>计算属性的名称</em> 。 当这些方括号之间传递一个对象时，它会将对象强制转换成一个字符串，所以我们得到一个属性键 <code>[object Object]</code> 和 值是 <code>{}</code> 。</p>
<p>同样的，我们也可以这样:</p>
<pre><code class="language-js">({ [{}]: { [{}]: {} } }[{}][{}]); // -&gt; {}

// structure:
// {
//   '[object Object]': {
//     '[object Object]': {}
//   }
// }
</code></pre>
<p>阅读更多关于对象 litarals 这里：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer">Object initializer</a> at MDN</li>
</ul>
<h2 id="访问原型-__proto__">访问原型 <code>__proto__</code></h2>
<p>正如我们所知道的，原本是没有原型。但是，如果我们尝试为原始对象获取一个 <code>__proto__</code> 的值，我们会得到这样的一个结果：</p>
<pre><code class="language-js">(1).__proto__.__proto__.__proto__; // -&gt; null
</code></pre>
<h3 id="说明-29">💡 说明:</h3>
<p>这是因为原本的没有原型，它将使用 <code>ToObject</code> 方法包装在包装器对象中。 所以，一步一步：</p>
<pre><code class="language-js">(1)
  .__proto__(
    // -&gt; [Number: 0]
    1
  )
  .__proto__.__proto__(
    // -&gt; {}
    1
  ).__proto__.__proto__.__proto__; // -&gt; null
</code></pre>
<p>以下是关于 <code>__proto__</code>的更多信息：</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-object.prototype.__proto__"><strong>B.2.2.1</strong> Object.prototype.<strong>proto</strong></a></li>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-toobject"><strong>7.1.13</strong> ToObject(<code>argument</code>)</a></li>
</ul>
<h2 id="object"><code>`${{Object}}`</code></h2>
<p>下面的表达结果如何？</p>
<pre><code class="language-js">`${{ Object }}`;
</code></pre>
<p>答案是：</p>
<pre><code class="language-js">// -&gt; '[object Object]'
</code></pre>
<h3 id="说明-30">💡 说明:</h3>
<p>我们使用一个属性 <code>object</code> 定义了一个对象:</p>
<pre><code class="language-js">{
  Object: Object;
}
</code></pre>
<p>然后我们将该对象传递给模板文字，因此 <code>toString</code> 方法调用该对象。 这就是为什么我们得到字符串 <code>'[object Object]'</code> 。</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-template-literals"><strong>12.2.9</strong> Template Literals</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer">Object initializer</a> at MDN</li>
</ul>
<h2 id="使用默认值进行结构化">使用默认值进行结构化</h2>
<p>思考这个例子：</p>
<pre><code class="language-js">let x,
  { x: y = 1 } = { x };
y;
</code></pre>
<p>上面的例子是访问的一个很好的任务。 <code>y</code> 有什么值？ 答案是：</p>
<pre><code class="language-js">// -&gt; 1
</code></pre>
<h3 id="说明-31">💡 说明:</h3>
<pre><code class="language-js">let x,
  { x: y = 1 } = { x };
y;
//  ↑       ↑           ↑    ↑
//  1       3           2    4
</code></pre>
<p>以上示例：</p>
<ol>
<li>我们声明 <code>x</code> 没有赋值，所以它是'undefined`。</li>
<li>然后我们将 <code>x</code> 的值打包到对象属性 <code>x</code> 中。</li>
<li>然后我们使用解构来提取 <code>x</code> 的值，并且要将这个值分配给 <code>y</code>。 如果未定义该值，那么我们将使用 <code>1</code> 作为默认值。</li>
<li>返回 <code>y</code> 的值。</li>
</ol>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer">Object initializer</a> at MDN</li>
</ul>
<h2 id="点-和-解构">点 和 解构</h2>
<p>有趣的例子可以由阵列的扩展组成。 考虑这个：</p>
<pre><code class="language-js">[...[...&quot;...&quot;]].length; // -&gt; 3
</code></pre>
<h3 id="说明-32">💡 说明:</h3>
<p>为什么是 3？当我们使用扩展运算符 TODO 链接到规范）时，<code>@@iterator</code> 方法调用，而返回的迭代器用于获取要迭代的值。字符串的默认迭代器按字符传播字符串。传播之后，我们把这些字符打包成一个数组。然后再展开这个数组并打包回数组</p>
<p>一个 <code>'...'</code> 字符串包含 <code>.</code> ，所以结果数组的长度将' 3 '。</p>
<p>现在，一步一步的看</p>
<pre><code class="language-js">[...'...']             // -&gt; [ '.', '.', '.' ]
[...[...'...']]        // -&gt; [ '.', '.', '.' ]
[...[...'...']].length // -&gt; 3
</code></pre>
<p>显然，我们可以像我们想要的那样传播和包装数组的元素：</p>
<pre><code class="language-js">[...'...']                 // -&gt; [ '.', '.', '.' ]
[...[...'...']]            // -&gt; [ '.', '.', '.' ]
[...[...[...'...']]]       // -&gt; [ '.', '.', '.' ]
[...[...[...[...'...']]]]  // -&gt; [ '.', '.', '.' ]
// and so on …
</code></pre>
<h2 id="标签">标签</h2>
<p>很多程序员不知道 JavaScript 中的标签。 但它们很实用</p>
<pre><code class="language-js">foo: {
  console.log(&quot;first&quot;);
  break foo;
  console.log(&quot;second&quot;);
}

// &gt; first
// -&gt; undefined
</code></pre>
<h3 id="说明-33">💡 说明:</h3>
<p>带标签的语句与 <code>break</code> 或 <code>continue</code> 语句一起使用。 您可以使用标签来标识循环，然后使用 <code>break</code> 或 <code>continue</code> 语句来指示程序是否应该中断循环或继续执行它。</p>
<p>在上面的例子中，我们识别一个标签 <code>foo</code> 。 然后 <code>console.log（'first'）;</code> 执行，然后中断执行。</p>
<p>详细了解 JavaScript 中的标签：</p>
<ul>
<li><a href="https://tc39.github.io/ecma262/#sec-labelled-statements"><strong>13.13</strong> 标签语句 </a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label">标签语句</a> at MDN</li>
</ul>
<h2 id="嵌套标签">嵌套标签</h2>
<pre><code class="language-js">a: b: c: d: e: f: g: 1, 2, 3, 4, 5; // -&gt; 5
</code></pre>
<h3 id="说明-34">💡 说明:</h3>
<p>像以前的例子一样，请遵循以下链接：</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-comma-operator"><strong>12.16</strong> 逗号运算符(<code>,</code>)</a></li>
<li><a href="https://tc39.github.io/ecma262/#sec-labelled-statements"><strong>13.13</strong> 标签语句</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label">标签语句</a> at MDN</li>
</ul>
<h2 id="阴险的-trycatch">阴险的 <code>try..catch</code></h2>
<p>这个表达将返回什么？ <code>2</code> 或 <code>3</code>？</p>
<pre><code class="language-js">(() =&gt; {
  try {
    return 2;
  } finally {
    return 3;
  }
})();
</code></pre>
<p>答案是 3。惊讶吗？</p>
<h3 id="说明-35">💡 说明:</h3>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-try-statement"><strong>13.15</strong> <code>try</code>声明 </a></li>
</ul>
<h2 id="这是多重继承吗">这是多重继承吗？</h2>
<p>看下面的例子：</p>
<pre><code class="language-js">new class F extends (String, Array) {}(); // -&gt; F []
</code></pre>
<p>这是多重继承吗？ 不。</p>
<h3 id="说明-36">💡 说明:</h3>
<p>有趣的部分是 <code>extends</code> 子句的值（ <code>（String，Array）</code> ）。 分组运算符总是返回其最后一个参数，所以 <code>（String，Array）</code> 实际上只是 <code>Array</code>。 这意味着我们刚刚创建了一个扩展 <code>Array</code> 的类。</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-class-definitions"><strong>14.5</strong> 类定义 </a></li>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-comma-operator"><strong>12.16</strong> 逗号运算符 (<code>,</code>)</a></li>
</ul>
<h2 id="a-generator-which-yields-itself">A generator which yields itself</h2>
<p>考虑一下这个例子，它产生了一个生成器：</p>
<pre><code class="language-js">(function* f() {
  yield f;
})().next();
// -&gt; { value: [GeneratorFunction: f], done: false }
</code></pre>
<p>如您所见，返回的值是一个值等于 <code>f</code> 的对象。那样的话，我们可以做这样的事情：</p>
<pre><code class="language-js">(function* f() {
  yield f;
})()
  .next()
  .value()
  .next()(
    // -&gt; { value: [GeneratorFunction: f], done: false }

    // and again
    function* f() {
      yield f;
    }
  )()
  .next()
  .value()
  .next()
  .value()
  .next()(
    // -&gt; { value: [GeneratorFunction: f], done: false }

    // and again
    function* f() {
      yield f;
    }
  )()
  .next()
  .value()
  .next()
  .value()
  .next()
  .value()
  .next();
// -&gt; { value: [GeneratorFunction: f], done: false }

// and so on
// …
</code></pre>
<h3 id="说明-37">💡 说明:</h3>
<p>要理解为什么这样工作，请阅读规范的这些部分：</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-control-abstraction-objects"><strong>25</strong> Control Abstraction Objects</a></li>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-generator-objects"><strong>25.3</strong> Generator Objects</a></li>
</ul>
<h2 id="一个类的类">一个类的类</h2>
<p>考虑这个混淆的语法游戏：</p>
<pre><code class="language-js">typeof new class {
  class() {}
}(); // -&gt; 'object'
</code></pre>
<p>似乎我们在类内部声明了一个类。应该和错误，然而，我们得到一个 <code>'object'</code> 字符串。</p>
<h3 id="说明-38">💡 说明:</h3>
<p>ECMAScript 5 时代以来，关键字允许访问属性。所以请考虑一下这个简单的对象示例：</p>
<pre><code class="language-js">const foo = {
  class: function() {}
};
</code></pre>
<p>和 6 标准速记方法定义。此外，类可能是匿名的。因此，如果我们放弃 <code>函数</code> 部分，我们将得到：</p>
<pre><code class="language-js">class {
  class() {}
}
</code></pre>
<p>默认类的结果总是一个简单的对象。其类型应返回 <code>'object'</code> 。</p>
<p>在这里阅读更多</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-method-definitions"><strong>14.3</strong> Method Definitions</a></li>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-class-definitions"><strong>14.5</strong> Class Definitions</a></li>
</ul>
<h2 id="非强制对象">非强制对象</h2>
<p>有着名的符号，有一种方法可以摆脱类型的强制。 看一看：</p>
<pre><code class="language-js">function nonCoercible(val) {
  if (val == null) {
    throw TypeError(&quot;nonCoercible should not be called with null or undefined&quot;);
  }

  const res = Object(val);

  res[Symbol.toPrimitive] = () =&gt; {
    throw TypeError(&quot;Trying to coerce non-coercible object&quot;);
  };

  return res;
}
</code></pre>
<p>现在我们可以这样使用：</p>
<pre><code class="language-js">// objects
const foo = nonCoercible({ foo: &quot;foo&quot; });

foo * 10; // -&gt; TypeError: Trying to coerce non-coercible object
foo + &quot;evil&quot;; // -&gt; TypeError: Trying to coerce non-coercible object

// strings
const bar = nonCoercible(&quot;bar&quot;);

bar + &quot;1&quot;; // -&gt; TypeError: Trying to coerce non-coercible object
bar.toString() + 1; // -&gt; bar1
bar === &quot;bar&quot;; // -&gt; false
bar.toString() === &quot;bar&quot;; // -&gt; true
bar == &quot;bar&quot;; // -&gt; TypeError: Trying to coerce non-coercible object

// numbers
const baz = nonCoercible(1);

baz == 1; // -&gt; TypeError: Trying to coerce non-coercible object
baz === 1; // -&gt; false
baz.valueOf() === 1; // -&gt; true
</code></pre>
<h3 id="说明-39">💡 说明:</h3>
<ul>
<li><a href="https://gist.github.com/chicoxyzzy/5dd24608e886adf5444499896dff1197">A gist by Sergey Rubanov</a></li>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-well-known-symbols"><strong>6.1.5.1</strong> Well-Known Symbols</a></li>
</ul>
<h2 id="棘手的箭头功能">棘手的箭头功能</h2>
<p>考虑下面的例子:</p>
<pre><code class="language-js">let f = () =&gt; 10;
f(); // -&gt; 10
</code></pre>
<p>好吧，但是这是怎么说的呢?</p>
<pre><code class="language-js">let f = () =&gt; {};
f(); // -&gt; undefined
</code></pre>
<h3 id="说明-40">💡 说明:</h3>
<p>你可以期待 <code>{}</code> 而不是 <code>undefined</code> 。这是因为花括号是箭头函数语法的一部分，所以 f 会返回未定义的。</p>
<h2 id="棘手的返回">棘手的返回</h2>
<p><code>return</code> 声明是很棘手的. 看下面的代码:</p>
<pre><code class="language-js">(function() {
  return;
  {
    b: 10;
  }
})(); // -&gt; undefined
</code></pre>
<h3 id="说明-41">💡 说明:</h3>
<p><code>return</code> 一个表达式必须在同一行:</p>
<pre><code class="language-js">(function() {
  return {
    b: 10
  };
})(); // -&gt; { b: 10 }
</code></pre>
<h2 id="使用数组访问对象属性">使用数组访问对象属性</h2>
<pre><code class="language-js">var obj = { property: 1 };
var array = [&quot;property&quot;];

obj[array]; // -&gt; 1
</code></pre>
<p>那关于维多维数组创建对象呢？</p>
<pre><code class="language-js">var map = {};
var x = 1;
var y = 2;
var z = 3;

map[[x, y, z]] = true;
map[[x + 10, y, z]] = true;

map[&quot;1,2,3&quot;]; // -&gt; true
map[&quot;11,2,3&quot;]; // -&gt; true
</code></pre>
<h3 id="说明-42">💡 说明:</h3>
<p>括号操作符将传递给字符串的表达式转换为字符串。将一个元素数组转换为字符串，就像将元素转换为字符串:</p>
<pre><code class="language-js">[&quot;property&quot;].toString(); // -&gt; 'property'`
</code></pre>
<h2 id="棘手的箭头函数">棘手的箭头函数</h2>
<p>思考一下下面的例子：</p>
<pre><code class="language-js">let f = () =&gt; 10;
f(); // -&gt; 10
</code></pre>
<p>好，很好，但是下面那个又输出什么？</p>
<pre><code class="language-js">let f = () =&gt; {};
f(); // -&gt; undefined
</code></pre>
<h3 id="说明-43">💡 说明:</h3>
<p>你可能会期望<code>{}</code>而不是<code>undefined</code>。这是因为花括号是箭头函数语法的一部分，所以 <code>f</code>将返回为定义。但是，可以直接从箭头函数中返回<code>{}</code>，采用括号括起来。</p>
<pre><code class="language-js">let f = () =&gt; ({});
f(); // -&gt; {}
</code></pre>
<h2 id="arguments和箭头函数"><code>arguments</code>和箭头函数</h2>
<p>思考一下下面的例子：</p>
<pre><code class="language-js">let f = function() {
  return arguments;
};
f(&quot;a&quot;); // -&gt; { '0': 'a' }
</code></pre>
<p>现在，试着用一个箭头函数来做同样的事情:</p>
<pre><code class="language-js">let f = () =&gt; arguments;
f(&quot;a&quot;); // -&gt; Uncaught ReferenceError: arguments is not defined
</code></pre>
<h3 id="说明-44">💡 说明:</h3>
<p>箭头函数是普通函数的轻量级版本，重点是简短和 <code>this</code> 上。与此同时，箭头函数不为 <code>arguments</code> 对象提供绑定。作为一个有效的替代使用 <code>rest parameters</code> 来达到相同的结果:</p>
<pre><code class="language-js">let f = (...args) =&gt; args;
f(&quot;a&quot;);
</code></pre>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a> at MDN.</li>
</ul>
<h2 id="棘手的返回值">棘手的返回值</h2>
<p><code>return</code> 也是很棘手。思考一下这个：</p>
<pre><code class="language-js">(function() {
  return;
  {
    b: 10;
  }
})(); // -&gt; undefined
</code></pre>
<h3 id="说明-45">💡 说明:</h3>
<p><code>return</code> 返回的表达式必须在同一行：</p>
<pre><code class="language-js">(function() {
  return {
    b: 10
  };
})(); // -&gt; { b: 10 }
</code></pre>
<p>这是因为一个概念叫自动分号，分号后，自动插入最新行。在第一个示例中，在<code>return</code>语句和对象文本之间插入一个分号，因此函数返回<code>undefined</code> 后面代码将不会被执行。</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-rules-of-automatic-semicolon-insertion"><strong>11.9.1</strong> 自动分号插入规则</a></li>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-return-statement"><strong>13.10</strong> <code>return</code> 声明</a></li>
</ul>
<h2 id="使用数组访问对象属性-2">使用数组访问对象属性</h2>
<pre><code class="language-js">var obj = { property: 1 };
var array = [&quot;property&quot;];

obj[array]; // -&gt; 1
</code></pre>
<p>伪多维数组呢？</p>
<pre><code class="language-js">var map = {};
var x = 1;
var y = 2;
var z = 3;

map[[x, y, z]] = true;
map[[x + 10, y, z]] = true;

map[&quot;1,2,3&quot;]; // -&gt; true
map[&quot;11,2,3&quot;]; // -&gt; true
</code></pre>
<h3 id="说明-46">💡 说明:</h3>
<p>方括号<code>[]</code>操作符使用<code>toString</code>进行转换，将一个元素数组转换为字符串:</p>
<pre><code class="language-js">[&quot;property&quot;].toString(); // -&gt; 'property'
</code></pre>
<h2 id="null-和关系运算符">Null 和关系运算符</h2>
<pre><code class="language-js">null &gt; 0; // false
null == 0; // false

null &gt;= 0; // true
</code></pre>
<h3 id="说明-47">💡 说明:</h3>
<p>长话短说，如果<code>null</code>小于<code>0</code>是<code>false</code>,那么<code>null &gt;= 0</code>则是<code>true</code>。<br>
请阅读下面的详细解释<a href="https://blog.campvanilla.com/javascript-the-curious-case-of-null-0-7b131644e274">这里</a>.</p>
<h2 id="numbertofixed显示不同的数字"><code>Number.toFixed()</code>显示不同的数字</h2>
<p><code>Number.toFixed()</code> 在不同的浏览器中会表现得有点奇怪。看看这个例子:</p>
<pre><code class="language-js">(0.7875).toFixed(3);
// Firefox: -&gt; 0.787
// Chrome: -&gt; 0.787
// IE11: -&gt; 0.788
(0.7876).toFixed(3);
// Firefox: -&gt; 0.788
// Chrome: -&gt; 0.788
// IE11: -&gt; 0.788
</code></pre>
<h3 id="说明-48">💡 说明:</h3>
<p>查看 Firefox 源码, <code>toFixed</code> 方法是转换的值，而不是标准的实现。</p>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262//#sec-number.prototype.tofixed"><strong>20.1.3.3</strong> Number.prototype.toFixed (<code>fractionDigits</code>)</a></li>
</ul>
<h2 id="比较null-to-0">比较<code>null</code> to <code>0</code></h2>
<p>下面的表达式似乎有点矛盾：</p>
<pre><code class="language-js">null == 0; // -&gt; false
null &gt; 0; // -&gt; false
null &gt;= 0; // -&gt; true
</code></pre>
<p><code>null</code>怎么既不等于也不大于<code>0</code>，如果<code>null &gt;= 0</code> 实际上是 <code>true</code>? (这也适用于少于同样的方法。)</p>
<h3 id="说明-49">💡 说明:</h3>
<p>执行这三个表达式的方式各不相同，并负责产生这种意外行为。<br>
首先，抽象相等比较<code>null == 0</code>。通常情况下，如果这个运算符不能正确地比较两边的值，则它将两个数字转换为数字，并对数字进行比较。然后，您可能会期望以下行为：</p>
<pre><code class="language-js">// 事实并非如此
(null == 0 + null) == +0;
0 == 0;
true;
</code></pre>
<p>然而，根据对规范的仔细阅读，数字转换实际上并没有发生在<code>null</code> 或 <code>undefined</code>的一侧。因此，如果在等号的一侧有<code>null</code>，则另一侧的表达式必须为<code>null</code> 或 <code>undefined</code>，以返回 <code>true</code>。既然不是这样，就会返回 false。</p>
<p>Next, the relational comparison <code>null &gt; 0</code>. The algorithm here, unlike that of the abstract equality operator, <em>will</em> convert <code>null</code> to a number. Therefore, we get this behavior:</p>
<p>接下来，关系比较 <code>null &gt; 0</code> 。这里的算法不同于抽象的相等运算符，将 <code>null</code> 转换为一个数字。因此，我们得到这样的行为:</p>
<pre><code class="language-js">null &gt; 0
+null = +0
0 &gt; 0
false
</code></pre>
<p>最后，关系比较<code>null &gt;= 0</code>。你可以认为这个表达式应该是 <code>null &gt; 0 || null == 0</code> 的结果;如果是这样，那么以上的结果将意味着这也是<code>false</code>。然而，<code>&gt;=</code>操作符实际上以一种非常不同的方式工作，这基本上与 <code>&lt;</code> 操作符相反。因为我们的例子中，大于运算符的例子也适用于小于运算符，也就是说这个表达式的值是这样的:</p>
<pre><code class="language-js">null &gt;= 0;
!(null &lt; 0);
!(+null &lt; +0);
!(0 &lt; 0);
!false;
true;
</code></pre>
<ul>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-abstract-relational-comparison"><strong>7.2.12</strong> 抽象的关系比较</a></li>
<li><a href="https://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison"><strong>7.2.13</strong> 比较抽象的平等</a></li>
</ul>
<h1 id="其他资源">其他资源</h1>
<ul>
<li><a href="http://wtfjs.com/">wtfjs.com</a> — 这是一组非常特别的不规范，不一致的地方，以及那些对于网络语言来说非常痛苦的不直观的时刻。</li>
<li><a href="https://www.destroyallsoftware.com/talks/wat">Wat</a> — A lightning talk by Gary Bernhardt from CodeMash 2012</li>
<li><a href="https://www.youtube.com/watch?v=2pL28CcEijU">What the... JavaScript?</a> — 凯尔。辛普森一家谈到了前两次试图从 JavaScript 中“拉出疯狂”的尝试。他希望帮助您生成更干净、更优雅、更可读的代码，然后鼓励人们为开源社区做出贡献。</li>
</ul>
<h1 id="license">🎓 License</h1>
<figure data-type="image" tabindex="2"><a href="http://www.wtfpl.net"><img src="https://img.shields.io/badge/License-WTFPL%202.0-lightgrey.svg?style=flat-square" alt="CC 4.0" loading="lazy"></a></figure>
<p>© <a href="http://denysdovhan.com">Denys Dovhan</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2019-年度总结]]></title>
        <id>https://heihei12305.github.io/post/2019-nian-du-zong-jie/</id>
        <link href="https://heihei12305.github.io/post/2019-nian-du-zong-jie/">
        </link>
        <updated>2019-12-31T15:13:59.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>2月 02-07 开始刷leetcode啦，陆陆续续总数也到345了，不无遗憾的想着356或许更好一些呢<br>
<img src="https://heihei12305.github.io/post-images/1577808277203.png" alt="" loading="lazy"></li>
<li>4 月，嘿嘿😄，遇到的她很🉑️呢，庆幸有机会牵手，真的很不错很不错呢，在一起也270天啦，😁，嗯～～快乐。<br>
<img src="https://heihei12305.github.io/post-images/1577843295764.jpeg" alt="" loading="lazy"></li>
<li>6月 06-10 重新开始github,之前一直没弄懂github怎么用的，会了之后发现真想，嗯～～虽然也没怎么向开源社区贡献🌚，至少会用已经有了的轮子了吧，还是很棒的。</li>
</ul>
<p><img src="https://heihei12305.github.io/post-images/1577808162803.png" alt="" loading="lazy"><br>
同期，开始用girdea写博客，一共100+啦，真滴香！<br>
<img src="https://heihei12305.github.io/post-images/1577843084234.png" alt="" loading="lazy"></p>
<ul>
<li>7月 07-03 加入掘金社区，找到了很喜欢的社区！阅读过的文章汇总957篇，小册已购15本，已看9本（双十一半价太香了，不过小册真滴不错呢）<s>其实👀的沸点更多的多的多</s>虽然写的文章获赞不理想😢<br>
<img src="https://heihei12305.github.io/post-images/1577843203357.png" alt="" loading="lazy"></li>
<li>8月 08-05 开启在极客时间学习之旅，从此地铁路上不再彷徨。地铁配极课时间，仿佛一切刚刚好。订阅7门课程，累计学习79天，学了37小时，学了209门课程。嗯，还是不错的，2020继续加油⛽️<br>
<img src="https://heihei12305.github.io/post-images/1577808380510.jpeg" alt="" loading="lazy"></li>
<li>8-10 疯狂准备面试中，你不知道的javaScript，css世界，各种大佬的博客，lodash源码的阅读。慢慢的觉得好像没那么慌张了。<br>
<img src="https://heihei12305.github.io/post-images/1577843590478.jpeg" alt="" loading="lazy"></li>
<li>10 月   10/12 开启第一次面试了呢，可惜没得后续结果了，陆陆续续，慢慢认识到了自己好像不太行～～～ 10/24 收到心仪offer，继续加油！ 10/28 租房子啦，搬家了嘿嘿😁<br>
<img src="https://heihei12305.github.io/post-images/1577843601571.jpeg" alt="" loading="lazy"></li>
<li>11月 入职啦，开启前端实习生生涯。</li>
<li>12月 各种事情巨多 学校/保定 &lt;-&gt; 公司/北京  两边跑还是很累的， 不过收到第一个月工资还是很开心的呢。</li>
</ul>
<h3 id="总结">总结</h3>
<br/>
<p>总算是入门前端了，工作前一直没人带，自己摸索还是很不容易的。但是呢，革命尚未成功，同志仍需努力💪。</p>
<br/>
<p>2020 你好</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ant-design-pro-vue修改指南🛠]]></title>
        <id>https://heihei12305.github.io/post/ant-design-pro-vue-xiu-gai-zhi-nan/</id>
        <link href="https://heihei12305.github.io/post/ant-design-pro-vue-xiu-gai-zhi-nan/">
        </link>
        <updated>2019-12-24T15:32:50.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>前一段时间用ant design pro of vue写了俩系统，趁着自己还记得怎么改的，记录一下。</p>
</blockquote>
<h3 id="登录框系列">登录框系列</h3>
<br/>
<p>系列文件📃在 <code>src/views/user</code>下，因为没有复用很多组件（不像ant design pro😭），</p>
<figure data-type="image" tabindex="1"><img src="https://heihei12305.github.io/post-images/1577202288794.png" alt="" loading="lazy"></figure>
<br/>
<p>直接修改这三个组件即可😊。</p>
<br/>
<blockquote>
<p>ps:不过这里把请求封装了，而且设计动态权限路由渲染那一套，建议改改形式就好了，其他的谨慎修改。⛏</p>
</blockquote>
<br/>
<h3 id="动态路由系列">动态路由系列</h3>
<br/>
<p>系列文件📃在 <code>src/config/router.config.js</code>,此处涉及动态路由列表渲染的具体情况，包括url，列表项名称，page名称等。</p>
<br/>
<p>例子：</p>
<pre><code>// forms
{
    path: '/index',
    redirect: '/index/welcome',
    component: RouteView,
    meta: { title: '主页', icon: 'form', permission: [ 'form' ] },
    children: [
        {
        path: '/index/welcome',
        name: 'welcome',
        component: () =&gt; import('@/views/form/BasicForm'),
        meta: { title: '欢迎页', keepAlive: true, permission: [ 'form' ] }
        }
    ]
},
</code></pre>
<p>说明：此处路由由forms修改而来，权限列表依旧为form，page名称为主页或者欢迎页。path指的是路由，compont指对应vue组件。🔧</p>
<br/>
<h3 id="跨域篇">跨域篇</h3>
<p>对应文件📃在<code>vue.config.js</code>,把proxy修改到对应后端端口即可。</p>
<pre><code>//此处代码位于vue.config.js 87行
devServer: {
    // development server port 8000
    port: 8000,
    // If you want to turn on the proxy, please remove the mockjs /src/main.jsL11
    proxy: {
      '/api/*': {
        target:'http://localhost:3000',
        // target:'http://202.206.212.212:9000',
        changeOrigin: true
      }
    }
  },
</code></pre>
<h3 id="ant组件使用篇">ant组件使用篇</h3>
<p>官网地址： <a href="http://vue.ant-design.cn/docs/vue/introduce-cn/">ant design vue</a></p>
<br/>
<p>在ant design pro vue 中使用方式：</p>
<ol>
<li>按需加载在<code>src/core/lazy_lib/components_use.js</code></li>
</ol>
<pre><code>//使用示例
import {
  Carousel
} from 'ant-design-vue'
Vue.use(Carousel)
</code></pre>
<p>文件其余部分不动即可，然后就可以直接使用。</p>
<br/>
<ol start="2">
<li>上文中我们引入了<code>Carousel</code>，使用时，我们需要用 <code>a-carousel</code></li>
</ol>
<pre><code>&lt;a-carousel 
    arrows 
    autoplay
    &gt;
    &lt;div
      slot=&quot;prevArrow&quot;
      class=&quot;custom-slick-arrow&quot;
      style=&quot;left: 10px;zIndex: 1&quot;
    &gt;
      &lt;a-icon type=&quot;left-circle&quot; /&gt;
    &lt;/div&gt;
    &lt;div slot=&quot;nextArrow&quot; class=&quot;custom-slick-arrow&quot; style=&quot;right: 10px&quot;&gt;
      &lt;a-icon type=&quot;right-circle&quot; /&gt;
    &lt;/div&gt;
    &lt;div&gt;&lt;h3&gt;重要通知：xxxx新书到啦&lt;/h3&gt;&lt;/div&gt;
    &lt;div&gt;&lt;h3&gt;老师给个优吧！&lt;/h3&gt;&lt;/div&gt;
    &lt;div&gt;&lt;h3&gt;不看错亿呀！图书馆使用指南&lt;/h3&gt;&lt;/div&gt;
  &lt;/a-carousel&gt;
</code></pre>
<br/>
<h3 id="取消mock篇">取消mock篇</h3>
<p>使用 ant design pro vue时，请求会被mock全部拦截😢</p>
<br/>
<p>取消其实也简单，Mock 在 main.js 中经行引入，你可以查看该文件的源代码，并找到 import './mock' 这样的代码。（去除它 可完整的将项目中的 mock 拦截去除）</p>
<br/>
<h3 id="请求发送篇">请求发送篇</h3>
<br/>
<p>别问，问就是axios😊<br/></p>
<p>本来项目就有用，只是它又给再封装📦了一层。<br/></p>
<p>使用很简单，引入，然后直接使用即可。</p>
<pre><code>&lt;script&gt;
import axios from 'axios'
methods: {
    getData () {
        axios.post('/api/admin/salary', {
        params: {
            'username': this.$store.getters.userInfo.roleId
        }
        }).then(result =&gt; {
        console.log(result.data.data)
        this.dataSource = result.data.data
        for (let i = 0, len = this.dataSource.length; i &lt; len; i++) {
            this.dataSource[i].key = i
        }
        })
    },
&lt;/script&gt;
</code></pre>
<h3 id="vue基础篇">vue基础篇</h3>
<p>可能使用到的vue的一些基础属性📖</p>
<ul>
<li>mountd  生命周期钩子函数的一个</li>
<li>computed 计算属性</li>
<li>data 使用的必须为返回值</li>
<li>components 使用的组件</li>
</ul>
<p>其余具体的 ant 组件相关配置见 ant design 组件库</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[webpack-进阶用法🚔]]></title>
        <id>https://heihei12305.github.io/post/webpack-jin-jie-yong-fa/</id>
        <link href="https://heihei12305.github.io/post/webpack-jin-jie-yong-fa/">
        </link>
        <updated>2019-12-23T15:30:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="自动清理构建目录产物">🏍 自动清理构建目录产物</h2>
<br/>
<h3 id="通过-npm-scripts清理构建目录">🚲 通过 <code>npm scripts</code>清理构建目录</h3>
<pre><code>rm -rf ./dist &amp;&amp; webpack
rimraf ./dist &amp;&amp; webpack
</code></pre>
<p>不过这个 <code>rm -rf</code> 看起来有点😨，不很优雅。</p>
<br/>
<h3 id="通过-clean-webpack-plugin-插件">🛵 通过 <code>clean-webpack-plugin</code> 插件</h3>
<br/>
<p><b>默认会删除output指定的输出目录</b></p>
<br/>
<pre><code>const { CleanWebpackPlugin } = require('clean-webpack-plugin')
module.exports = {
    entry:{
        app:'./src/app.js',
        search:'./src/search.js'
    },
    output:{
        filename:'[name][chunkhash:8].js',
        path:__dirname+'/dist'
    },
    plugins:[
        new CleanWebpackPlugin()
    ]
};
</code></pre>
<br/>
<hr>
<br/>
<h2 id="postcss插件自动补全css3前缀">postCss插件自动补全css3前缀🏄‍♀</h2>
<h3 id="为什么css3需要添加前缀呢">为什么css3需要添加前缀呢？🏊‍♀</h3>
<p>原因：因为浏览器的标准还没有完全统一，目前来看主要还有四种浏览器内核，分别是：</p>
<ul>
<li>⛹️‍♀️Trident(-ms)</li>
<li>⛹Geko(-moz)</li>
<li>🤾‍♀Webkit(-webkit)</li>
<li>🤾‍♂Presto(-o)</li>
</ul>
<br/>
<h3 id="使用autoprefixer插件">使用autoprefixer插件🏊</h3>
<br/>
<p>原理：🤼‍♂根据<a href="https://caniuse.com/">Cab I Use规则</a></p>
<br/>
<pre><code>module.exports = {
  module:{
    rules:[
      {
        test:/\.less$/,
        use:[
          'style-loader',
          'css-loader',
          'less-loader',
           {
            loader:'postcss-loader',
            options:{
              plugins:() =&gt; {
                require('autoprefixer')({
                    browsers:[&quot;last 2 version&quot;,&quot;&gt;1%&quot;,&quot;iOS 7&quot;]
                })
              }
            }
          }
        ]
       }
     ]
  }
}
</code></pre>
]]></content>
    </entry>
</feed>